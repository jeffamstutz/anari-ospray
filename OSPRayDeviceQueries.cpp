// Copyright 2021 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_queries.py
// Don't make changes to this directly

#include <anari/anari.h>
#include <math.h>
#include <stdint.h>
namespace anari_ospray {
static int subtype_hash(const char *str)
{
  static const uint32_t table[] = {0x7a6f0012u,
      0x6a65002bu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6e6d0047u,
      0x0u,
      0x0u,
      0x0u,
      0x62610051u,
      0x0u,
      0x73720056u,
      0x70610062u,
      0x76750088u,
      0x0u,
      0x7563008cu,
      0x737200c1u,
      0x6f6e001du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720020u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c0024u,
      0x6665001eu,
      0x100001fu,
      0x80000000u,
      0x77760021u,
      0x66650022u,
      0x1000023u,
      0x80000001u,
      0x6a690025u,
      0x6f6e0026u,
      0x65640027u,
      0x66650028u,
      0x73720029u,
      0x100002au,
      0x80000002u,
      0x67620030u,
      0x0u,
      0x0u,
      0x0u,
      0x7372003du,
      0x76750035u,
      0x0u,
      0x0u,
      0x0u,
      0x62610038u,
      0x68670036u,
      0x1000037u,
      0x80000003u,
      0x76750039u,
      0x6d6c003au,
      0x7574003bu,
      0x100003cu,
      0x80000004u,
      0x6665003eu,
      0x6463003fu,
      0x75740040u,
      0x6a690041u,
      0x706f0042u,
      0x6f6e0043u,
      0x62610044u,
      0x6d6c0045u,
      0x1000046u,
      0x80000005u,
      0x62610048u,
      0x68670049u,
      0x6665004au,
      0x3331004bu,
      0x4544004du,
      0x4544004fu,
      0x100004eu,
      0x80000006u,
      0x1000050u,
      0x80000007u,
      0x75740052u,
      0x75740053u,
      0x66650054u,
      0x1000055u,
      0x80000008u,
      0x75740057u,
      0x69680058u,
      0x706f0059u,
      0x6867005au,
      0x7372005bu,
      0x6261005cu,
      0x7170005du,
      0x6968005eu,
      0x6a69005fu,
      0x64630060u,
      0x1000061u,
      0x80000009u,
      0x75740071u,
      0x0u,
      0x0u,
      0x0u,
      0x7372007au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a690084u,
      0x69680072u,
      0x75740073u,
      0x73720074u,
      0x62610075u,
      0x64630076u,
      0x66650077u,
      0x73720078u,
      0x1000079u,
      0x8000000au,
      0x7473007bu,
      0x7170007cu,
      0x6665007du,
      0x6463007eu,
      0x7574007fu,
      0x6a690080u,
      0x77760081u,
      0x66650082u,
      0x1000083u,
      0x8000000bu,
      0x6f6e0085u,
      0x75740086u,
      0x1000087u,
      0x8000000cu,
      0x62610089u,
      0x6564008au,
      0x100008bu,
      0x8000000du,
      0x6a69009eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706800a3u,
      0x0u,
      0x0u,
      0x0u,
      0x737200b1u,
      0x7776009fu,
      0x6a6900a0u,
      0x747300a1u,
      0x10000a2u,
      0x8000000eu,
      0x666500abu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x757400afu,
      0x737200acu,
      0x666500adu,
      0x10000aeu,
      0x8000000fu,
      0x10000b0u,
      0x80000010u,
      0x767500b2u,
      0x646300b3u,
      0x757400b4u,
      0x767500b5u,
      0x737200b6u,
      0x666500b7u,
      0x656400b8u,
      0x535200b9u,
      0x666500bau,
      0x686700bbu,
      0x767500bcu,
      0x6d6c00bdu,
      0x626100beu,
      0x737200bfu,
      0x10000c0u,
      0x80000011u,
      0x6a6100c2u,
      0x6f6e00cbu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626100dbu,
      0x747300ccu,
      0x676600cdu,
      0x666500ceu,
      0x737200cfu,
      0x474600d0u,
      0x767500d1u,
      0x6f6e00d2u,
      0x646300d3u,
      0x757400d4u,
      0x6a6900d5u,
      0x706f00d6u,
      0x6f6e00d7u,
      0x323100d8u,
      0x454400d9u,
      0x10000dau,
      0x80000012u,
      0x6f6e00dcu,
      0x686700ddu,
      0x6d6c00deu,
      0x666500dfu,
      0x10000e0u,
      0x80000013u};
  uint32_t cur = 0x75630000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static int param_hash(const char *str)
{
  static const uint32_t table[] = {0x746c0017u,
      0x626100a1u,
      0x70610107u,
      0x6a61016du,
      0x0u,
      0x7061018cu,
      0x736501ddu,
      0x666501f6u,
      0x736d01fcu,
      0x0u,
      0x0u,
      0x6a6902eau,
      0x6a610349u,
      0x666103a7u,
      0x767003b2u,
      0x7369041eu,
      0x0u,
      0x70610486u,
      0x766804b2u,
      0x7372054bu,
      0x71700554u,
      0x70610556u,
      0x736f064cu,
      0x716c001fu,
      0x6362004eu,
      0x0u,
      0x54440070u,
      0x6665008fu,
      0x0u,
      0x0u,
      0x7170009cu,
      0x706f0024u,
      0x0u,
      0x0u,
      0x0u,
      0x69680037u,
      0x78770025u,
      0x4a490026u,
      0x6f6e0027u,
      0x77760028u,
      0x62610029u,
      0x6d6c002au,
      0x6a69002bu,
      0x6564002cu,
      0x4e4d002du,
      0x6261002eu,
      0x7574002fu,
      0x66650030u,
      0x73720031u,
      0x6a690032u,
      0x62610033u,
      0x6d6c0034u,
      0x74730035u,
      0x1000036u,
      0x80000000u,
      0x62610038u,
      0x4e430039u,
      0x76750044u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f004au,
      0x75740045u,
      0x706f0046u,
      0x67660047u,
      0x67660048u,
      0x1000049u,
      0x80000001u,
      0x6564004bu,
      0x6665004cu,
      0x100004du,
      0x80000002u,
      0x6a69004fu,
      0x66650050u,
      0x6f6e0051u,
      0x75740052u,
      0x53430053u,
      0x706f0063u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610068u,
      0x6d6c0064u,
      0x706f0065u,
      0x73720066u,
      0x1000067u,
      0x80000003u,
      0x65640069u,
      0x6a69006au,
      0x6261006bu,
      0x6f6e006cu,
      0x6463006du,
      0x6665006eu,
      0x100006fu,
      0x80000004u,
      0x6a690080u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610088u,
      0x74730081u,
      0x75740082u,
      0x62610083u,
      0x6f6e0084u,
      0x64630085u,
      0x66650086u,
      0x1000087u,
      0x80000005u,
      0x6e6d0089u,
      0x7170008au,
      0x6d6c008bu,
      0x6665008cu,
      0x7473008du,
      0x100008eu,
      0x80000006u,
      0x73720090u,
      0x75740091u,
      0x76750092u,
      0x73720093u,
      0x66650094u,
      0x53520095u,
      0x62610096u,
      0x65640097u,
      0x6a690098u,
      0x76750099u,
      0x7473009au,
      0x100009bu,
      0x80000007u,
      0x6665009du,
      0x6463009eu,
      0x7574009fu,
      0x10000a0u,
      0x80000008u,
      0x646300a2u,
      0x6c6b00a3u,
      0x686700a4u,
      0x737200a5u,
      0x706f00a6u,
      0x767500a7u,
      0x6f6e00a8u,
      0x656400a9u,
      0x530000aau,
      0x80000009u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x666500fdu,
      0x676600feu,
      0x737200ffu,
      0x62610100u,
      0x64630101u,
      0x75740102u,
      0x6a690103u,
      0x706f0104u,
      0x6f6e0105u,
      0x1000106u,
      0x8000000au,
      0x716d0116u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610120u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c0132u,
      0x6665011au,
      0x0u,
      0x0u,
      0x7473011eu,
      0x7372011bu,
      0x6261011cu,
      0x100011du,
      0x8000000bu,
      0x100011fu,
      0x8000000cu,
      0x6f6e0121u,
      0x6f6e0122u,
      0x66650123u,
      0x6d6c0124u,
      0x2f2e0125u,
      0x65630126u,
      0x706f0128u,
      0x6665012du,
      0x6d6c0129u,
      0x706f012au,
      0x7372012bu,
      0x100012cu,
      0x8000000du,
      0x7170012eu,
      0x7574012fu,
      0x69680130u,
      0x1000131u,
      0x8000000eu,
      0x706f0133u,
      0x73720134u,
      0x2f000135u,
      0x8000000fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x71700164u,
      0x706f0165u,
      0x74730166u,
      0x6a690167u,
      0x75740168u,
      0x6a690169u,
      0x706f016au,
      0x6f6e016bu,
      0x100016cu,
      0x80000010u,
      0x75740176u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0179u,
      0x0u,
      0x0u,
      0x0u,
      0x73720184u,
      0x62610177u,
      0x1000178u,
      0x80000011u,
      0x7473017au,
      0x6a69017bu,
      0x7574017cu,
      0x7a79017du,
      0x5453017eu,
      0x6463017fu,
      0x62610180u,
      0x6d6c0181u,
      0x66650182u,
      0x1000183u,
      0x80000012u,
      0x66650185u,
      0x64630186u,
      0x75740187u,
      0x6a690188u,
      0x706f0189u,
      0x6f6e018au,
      0x100018bu,
      0x80000013u,
      0x736c019bu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6501adu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x776301bcu,
      0x6d6c01a2u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x10001acu,
      0x706f01a3u,
      0x676601a4u,
      0x676601a5u,
      0x424101a6u,
      0x6f6e01a7u,
      0x686701a8u,
      0x6d6c01a9u,
      0x666501aau,
      0x10001abu,
      0x80000014u,
      0x80000015u,
      0x6d6c01b5u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x757401b8u,
      0x656401b6u,
      0x10001b7u,
      0x80000016u,
      0x666501b9u,
      0x737201bau,
      0x10001bbu,
      0x80000017u,
      0x767501d0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7a7901dbu,
      0x747301d1u,
      0x454401d2u,
      0x6a6901d3u,
      0x747301d4u,
      0x757401d5u,
      0x626101d6u,
      0x6f6e01d7u,
      0x646301d8u,
      0x666501d9u,
      0x10001dau,
      0x80000018u,
      0x10001dcu,
      0x80000019u,
      0x706f01ebu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f01f2u,
      0x6e6d01ecu,
      0x666501edu,
      0x757401eeu,
      0x737201efu,
      0x7a7901f0u,
      0x10001f1u,
      0x8000001au,
      0x767501f3u,
      0x717001f4u,
      0x10001f5u,
      0x8000001bu,
      0x6a6901f7u,
      0x686701f8u,
      0x696801f9u,
      0x757401fau,
      0x10001fbu,
      0x8000001cu,
      0x62610202u,
      0x7741025eu,
      0x0u,
      0x0u,
      0x0u,
      0x737202e1u,
      0x68670203u,
      0x66650204u,
      0x53000205u,
      0x8000001du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66650258u,
      0x68670259u,
      0x6a69025au,
      0x706f025bu,
      0x6f6e025cu,
      0x100025du,
      0x8000001eu,
      0x75740294u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6766029du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x737202a3u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x757402acu,
      0x666502b2u,
      0x0u,
      0x626102cfu,
      0x75740295u,
      0x73720296u,
      0x6a690297u,
      0x63620298u,
      0x76750299u,
      0x7574029au,
      0x6665029bu,
      0x100029cu,
      0x8000001fu,
      0x6766029eu,
      0x7473029fu,
      0x666502a0u,
      0x757402a1u,
      0x10002a2u,
      0x80000020u,
      0x626102a4u,
      0x6f6e02a5u,
      0x747302a6u,
      0x676602a7u,
      0x706f02a8u,
      0x737202a9u,
      0x6e6d02aau,
      0x10002abu,
      0x80000021u,
      0x626102adu,
      0x6f6e02aeu,
      0x646302afu,
      0x666502b0u,
      0x10002b1u,
      0x80000022u,
      0x736e02b3u,
      0x747302b8u,
      0x0u,
      0x0u,
      0x0u,
      0x717002bdu,
      0x6a6902b9u,
      0x757402bau,
      0x7a7902bbu,
      0x10002bcu,
      0x80000023u,
      0x767502beu,
      0x717002bfu,
      0x6a6902c0u,
      0x6d6c02c1u,
      0x6d6c02c2u,
      0x626102c3u,
      0x737202c4u,
      0x7a7902c5u,
      0x454402c6u,
      0x6a6902c7u,
      0x747302c8u,
      0x757402c9u,
      0x626102cau,
      0x6f6e02cbu,
      0x646302ccu,
      0x666502cdu,
      0x10002ceu,
      0x80000024u,
      0x6d6c02d0u,
      0x6a6902d1u,
      0x656402d2u,
      0x4e4d02d3u,
      0x626102d4u,
      0x757402d5u,
      0x666502d6u,
      0x737202d7u,
      0x6a6902d8u,
      0x626102d9u,
      0x6d6c02dau,
      0x444302dbu,
      0x706f02dcu,
      0x6d6c02ddu,
      0x706f02deu,
      0x737202dfu,
      0x10002e0u,
      0x80000025u,
      0x626102e2u,
      0x656402e3u,
      0x6a6902e4u,
      0x626102e5u,
      0x6f6e02e6u,
      0x646302e7u,
      0x666502e8u,
      0x10002e9u,
      0x80000026u,
      0x686702ebu,
      0x696802ecu,
      0x757402edu,
      0x540002eeu,
      0x80000027u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610342u,
      0x6e6d0343u,
      0x71700344u,
      0x6d6c0345u,
      0x66650346u,
      0x74730347u,
      0x1000348u,
      0x80000028u,
      0x79740352u,
      0x0u,
      0x0u,
      0x0u,
      0x75740394u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0399u,
      0x66650357u,
      0x0u,
      0x0u,
      0x0u,
      0x5443035du,
      0x73720358u,
      0x6a690359u,
      0x6261035au,
      0x6d6c035bu,
      0x100035cu,
      0x80000029u,
      0x706f036eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6261037au,
      0x0u,
      0x0u,
      0x64630384u,
      0x6f6e036fu,
      0x75740370u,
      0x73720371u,
      0x6a690372u,
      0x63620373u,
      0x76750374u,
      0x75740375u,
      0x6a690376u,
      0x706f0377u,
      0x6f6e0378u,
      0x1000379u,
      0x8000002au,
      0x7574037bu,
      0x6968037cu,
      0x4d4c037du,
      0x6665037eu,
      0x6f6e037fu,
      0x68670380u,
      0x75740381u,
      0x69680382u,
      0x1000383u,
      0x8000002bu,
      0x62610385u,
      0x75740386u,
      0x75740387u,
      0x66650388u,
      0x73720389u,
      0x6a69038au,
      0x6f6e038bu,
      0x6867038cu,
      0x4645038du,
      0x7776038eu,
      0x6665038fu,
      0x6f6e0390u,
      0x75740391u,
      0x74730392u,
      0x1000393u,
      0x8000002cu,
      0x69680395u,
      0x706f0396u,
      0x65640397u,
      0x1000398u,
      0x8000002du,
      0x4443039au,
      0x706f039bu,
      0x6f6e039cu,
      0x7574039du,
      0x7372039eu,
      0x6a69039fu,
      0x636203a0u,
      0x767503a1u,
      0x757403a2u,
      0x6a6903a3u,
      0x706f03a4u,
      0x6f6e03a5u,
      0x10003a6u,
      0x8000002eu,
      0x6e6d03acu,
      0x0u,
      0x0u,
      0x0u,
      0x626103afu,
      0x666503adu,
      0x10003aeu,
      0x8000002fu,
      0x737203b0u,
      0x10003b1u,
      0x80000030u,
      0x666103b8u,
      0x0u,
      0x6a690403u,
      0x0u,
      0x0u,
      0x75740408u,
      0x646303bdu,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e03f9u,
      0x6a6903beu,
      0x757403bfu,
      0x7a7903c0u,
      0x2f0003c1u,
      0x80000031u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x717003f0u,
      0x706f03f1u,
      0x747303f2u,
      0x6a6903f3u,
      0x757403f4u,
      0x6a6903f5u,
      0x706f03f6u,
      0x6f6e03f7u,
      0x10003f8u,
      0x80000032u,
      0x6a6903fau,
      0x6f6e03fbu,
      0x686703fcu,
      0x424103fdu,
      0x6f6e03feu,
      0x686703ffu,
      0x6d6c0400u,
      0x66650401u,
      0x1000402u,
      0x80000033u,
      0x68670404u,
      0x6a690405u,
      0x6f6e0406u,
      0x1000407u,
      0x80000034u,
      0x554f0409u,
      0x6766040fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720415u,
      0x67660410u,
      0x74730411u,
      0x66650412u,
      0x75740413u,
      0x1000414u,
      0x80000035u,
      0x62610416u,
      0x6f6e0417u,
      0x74730418u,
      0x67660419u,
      0x706f041au,
      0x7372041bu,
      0x6e6d041cu,
      0x100041du,
      0x80000036u,
      0x79780428u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x78730433u,
      0x0u,
      0x0u,
      0x6a690441u,
      0x66650429u,
      0x6d6c042au,
      0x5453042bu,
      0x6261042cu,
      0x6e6d042du,
      0x7170042eu,
      0x6d6c042fu,
      0x66650430u,
      0x74730431u,
      0x1000432u,
      0x80000037u,
      0x6a690438u,
      0x0u,
      0x0u,
      0x0u,
      0x6665043eu,
      0x75740439u,
      0x6a69043au,
      0x706f043bu,
      0x6f6e043cu,
      0x100043du,
      0x80000038u,
      0x7372043fu,
      0x1000440u,
      0x80000039u,
      0x6e6d0442u,
      0x6a690443u,
      0x75740444u,
      0x6a690445u,
      0x77760446u,
      0x66650447u,
      0x2f2e0448u,
      0x73610449u,
      0x7574045bu,
      0x0u,
      0x706f046bu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6f640470u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610480u,
      0x7574045cu,
      0x7372045du,
      0x6a69045eu,
      0x6362045fu,
      0x76750460u,
      0x75740461u,
      0x66650462u,
      0x34300463u,
      0x1000467u,
      0x1000468u,
      0x1000469u,
      0x100046au,
      0x8000003au,
      0x8000003bu,
      0x8000003cu,
      0x8000003du,
      0x6d6c046cu,
      0x706f046du,
      0x7372046eu,
      0x100046fu,
      0x8000003eu,
      0x100047bu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6564047cu,
      0x8000003fu,
      0x6665047du,
      0x7978047eu,
      0x100047fu,
      0x80000040u,
      0x65640481u,
      0x6a690482u,
      0x76750483u,
      0x74730484u,
      0x1000485u,
      0x80000041u,
      0x65640495u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e049au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x767504a1u,
      0x6a690496u,
      0x76750497u,
      0x74730498u,
      0x1000499u,
      0x80000042u,
      0x6564049bu,
      0x6665049cu,
      0x7372049du,
      0x6665049eu,
      0x7372049fu,
      0x10004a0u,
      0x80000043u,
      0x6d6c04a2u,
      0x666504a3u,
      0x757404a4u,
      0x757404a5u,
      0x666504a6u,
      0x515004a7u,
      0x626104a8u,
      0x757404a9u,
      0x696804aau,
      0x4d4c04abu,
      0x666504acu,
      0x6f6e04adu,
      0x686704aeu,
      0x757404afu,
      0x696804b0u,
      0x10004b1u,
      0x80000044u,
      0x626104c0u,
      0x7b7a04c6u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626104c9u,
      0x0u,
      0x0u,
      0x0u,
      0x666104cfu,
      0x73720545u,
      0x656404c1u,
      0x706f04c2u,
      0x787704c3u,
      0x747304c4u,
      0x10004c5u,
      0x80000045u,
      0x666504c7u,
      0x10004c8u,
      0x80000046u,
      0x646304cau,
      0x6a6904cbu,
      0x6f6e04ccu,
      0x686704cdu,
      0x10004ceu,
      0x80000047u,
      0x757404d4u,
      0x0u,
      0x0u,
      0x0u,
      0x7372053du,
      0x767504d5u,
      0x747304d6u,
      0x444304d7u,
      0x626104d8u,
      0x6d6c04d9u,
      0x6d6c04dau,
      0x636204dbu,
      0x626104dcu,
      0x646304ddu,
      0x6c6b04deu,
      0x560004dfu,
      0x80000048u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x74730535u,
      0x66650536u,
      0x73720537u,
      0x45440538u,
      0x62610539u,
      0x7574053au,
      0x6261053bu,
      0x100053cu,
      0x80000049u,
      0x6665053eu,
      0x706f053fu,
      0x4e4d0540u,
      0x706f0541u,
      0x65640542u,
      0x66650543u,
      0x1000544u,
      0x8000004au,
      0x67660546u,
      0x62610547u,
      0x64630548u,
      0x66650549u,
      0x100054au,
      0x8000004bu,
      0x6261054cu,
      0x6f6e054du,
      0x7473054eu,
      0x6766054fu,
      0x706f0550u,
      0x73720551u,
      0x6e6d0552u,
      0x1000553u,
      0x8000004cu,
      0x1000555u,
      0x8000004du,
      0x736c0565u,
      0x0u,
      0x0u,
      0x0u,
      0x73720583u,
      0x0u,
      0x0u,
      0x0u,
      0x747305dcu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c05e8u,
      0x7675056cu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a690574u,
      0x6665056du,
      0x5352056eu,
      0x6261056fu,
      0x6f6e0570u,
      0x68670571u,
      0x66650572u,
      0x1000573u,
      0x8000004eu,
      0x62610575u,
      0x6f6e0576u,
      0x64630577u,
      0x66650578u,
      0x55540579u,
      0x6968057au,
      0x7372057bu,
      0x6665057cu,
      0x7473057du,
      0x6968057eu,
      0x706f057fu,
      0x6d6c0580u,
      0x65640581u,
      0x1000582u,
      0x8000004fu,
      0x75740584u,
      0x66650585u,
      0x79780586u,
      0x2f2e0587u,
      0x75610588u,
      0x7574059cu,
      0x0u,
      0x706105acu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f05c1u,
      0x0u,
      0x706f05c7u,
      0x0u,
      0x626105cfu,
      0x0u,
      0x626105d5u,
      0x7574059du,
      0x7372059eu,
      0x6a69059fu,
      0x636205a0u,
      0x767505a1u,
      0x757405a2u,
      0x666505a3u,
      0x343005a4u,
      0x10005a8u,
      0x10005a9u,
      0x10005aau,
      0x10005abu,
      0x80000050u,
      0x80000051u,
      0x80000052u,
      0x80000053u,
      0x717005bbu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c05bdu,
      0x10005bcu,
      0x80000054u,
      0x706f05beu,
      0x737205bfu,
      0x10005c0u,
      0x80000055u,
      0x737205c2u,
      0x6e6d05c3u,
      0x626105c4u,
      0x6d6c05c5u,
      0x10005c6u,
      0x80000056u,
      0x747305c8u,
      0x6a6905c9u,
      0x757405cau,
      0x6a6905cbu,
      0x706f05ccu,
      0x6f6e05cdu,
      0x10005ceu,
      0x80000057u,
      0x656405d0u,
      0x6a6905d1u,
      0x767505d2u,
      0x747305d3u,
      0x10005d4u,
      0x80000058u,
      0x6f6e05d6u,
      0x686705d7u,
      0x666505d8u,
      0x6f6e05d9u,
      0x757405dau,
      0x10005dbu,
      0x80000059u,
      0x6a6905ddu,
      0x636205deu,
      0x6d6c05dfu,
      0x666505e0u,
      0x4d4c05e1u,
      0x6a6905e2u,
      0x686705e3u,
      0x696805e4u,
      0x757405e5u,
      0x747305e6u,
      0x10005e7u,
      0x8000005au,
      0x767505e9u,
      0x6e6d05eau,
      0x666505ebu,
      0x540005ecu,
      0x8000005bu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610640u,
      0x6e6d0641u,
      0x71700642u,
      0x6d6c0643u,
      0x6a690644u,
      0x6f6e0645u,
      0x68670646u,
      0x53520647u,
      0x62610648u,
      0x75740649u,
      0x6665064au,
      0x100064bu,
      0x8000005cu,
      0x73720650u,
      0x0u,
      0x0u,
      0x62610654u,
      0x6d6c0651u,
      0x65640652u,
      0x1000653u,
      0x8000005du,
      0x71700655u,
      0x4e4d0656u,
      0x706f0657u,
      0x65640658u,
      0x66650659u,
      0x3331065au,
      0x100065cu,
      0x100065du,
      0x8000005eu,
      0x8000005fu};
  uint32_t cur = 0x78610000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static int info_hash(const char *str)
{
  static const uint32_t table[] = {0x69680014u,
      0x6665001bu,
      0x6d6c0038u,
      0x66650043u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a61004au,
      0x0u,
      0x0u,
      0x6261005fu,
      0x0u,
      0x66650068u,
      0x706f0070u,
      0x0u,
      0x7473007du,
      0x62610080u,
      0x62610015u,
      0x6f6e0016u,
      0x6f6e0017u,
      0x66650018u,
      0x6d6c0019u,
      0x100001au,
      0x8000000au,
      0x7466001cu,
      0x6261002au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6463002fu,
      0x7675002bu,
      0x6d6c002cu,
      0x7574002du,
      0x100002eu,
      0x80000001u,
      0x73720030u,
      0x6a690031u,
      0x71700032u,
      0x75740033u,
      0x6a690034u,
      0x706f0035u,
      0x6f6e0036u,
      0x1000037u,
      0x80000004u,
      0x66650039u,
      0x6e6d003au,
      0x6665003bu,
      0x6f6e003cu,
      0x7574003du,
      0x5554003eu,
      0x7a79003fu,
      0x71700040u,
      0x66650041u,
      0x1000042u,
      0x80000005u,
      0x62610044u,
      0x75740045u,
      0x76750046u,
      0x73720047u,
      0x66650048u,
      0x1000049u,
      0x80000008u,
      0x79780053u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0059u,
      0x6a690054u,
      0x6e6d0055u,
      0x76750056u,
      0x6e6d0057u,
      0x1000058u,
      0x80000003u,
      0x6a69005au,
      0x6e6d005bu,
      0x7675005cu,
      0x6e6d005du,
      0x100005eu,
      0x80000002u,
      0x73720060u,
      0x62610061u,
      0x6e6d0062u,
      0x66650063u,
      0x75740064u,
      0x66650065u,
      0x73720066u,
      0x1000067u,
      0x80000009u,
      0x72710069u,
      0x7675006au,
      0x6a69006bu,
      0x7372006cu,
      0x6665006du,
      0x6564006eu,
      0x100006fu,
      0x80000000u,
      0x76750071u,
      0x73720072u,
      0x64630073u,
      0x66650074u,
      0x47460075u,
      0x66650076u,
      0x62610077u,
      0x75740078u,
      0x76750079u,
      0x7372007au,
      0x6665007bu,
      0x100007cu,
      0x80000007u,
      0x6665007eu,
      0x100007fu,
      0x8000000bu,
      0x6d6c0081u,
      0x76750082u,
      0x66650083u,
      0x1000084u,
      0x80000006u};
  uint32_t cur = 0x77630000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static const int32_t anari_true = 1;
static const int32_t anari_false = 0;
const char **query_extensions()
{
  static const char *features[] = {"ANARI_KHR_CAMERA_ORTHOGRAPHIC",
      "ANARI_KHR_CAMERA_PERSPECTIVE",
      "ANARI_KHR_GEOMETRY_CONE",
      "ANARI_KHR_GEOMETRY_CURVE",
      "ANARI_KHR_GEOMETRY_CYLINDER",
      "ANARI_KHR_GEOMETRY_QUAD",
      "ANARI_KHR_GEOMETRY_SPHERE",
      "ANARI_KHR_GEOMETRY_TRIANGLE",
      "ANARI_KHR_LIGHT_DIRECTIONAL",
      "ANARI_KHR_LIGHT_POINT",
      "ANARI_KHR_LIGHT_SPOT",
      "ANARI_KHR_MATERIAL_MATTE",
      "ANARI_KHR_SAMPLER_IMAGE1D",
      "ANARI_KHR_SAMPLER_IMAGE2D",
      "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
      "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
      0};
  return features;
}
const char **query_object_types(ANARIDataType type)
{
  switch (type) {
  case ANARI_RENDERER: {
    static const char *ANARI_RENDERER_subtypes[] = {
        "default", "pathtracer", "scivis", "debug", 0};
    return ANARI_RENDERER_subtypes;
  }
  case ANARI_CAMERA: {
    static const char *ANARI_CAMERA_subtypes[] = {
        "orthographic", "perspective", 0};
    return ANARI_CAMERA_subtypes;
  }
  case ANARI_GEOMETRY: {
    static const char *ANARI_GEOMETRY_subtypes[] = {
        "cone", "curve", "cylinder", "quad", "sphere", "triangle", 0};
    return ANARI_GEOMETRY_subtypes;
  }
  case ANARI_LIGHT: {
    static const char *ANARI_LIGHT_subtypes[] = {
        "directional", "point", "spot", 0};
    return ANARI_LIGHT_subtypes;
  }
  case ANARI_MATERIAL: {
    static const char *ANARI_MATERIAL_subtypes[] = {"matte", 0};
    return ANARI_MATERIAL_subtypes;
  }
  case ANARI_SAMPLER: {
    static const char *ANARI_SAMPLER_subtypes[] = {"image1D", "image2D", 0};
    return ANARI_SAMPLER_subtypes;
  }
  case ANARI_SPATIAL_FIELD: {
    static const char *ANARI_SPATIAL_FIELD_subtypes[] = {
        "structuredRegular", 0};
    return ANARI_SPATIAL_FIELD_subtypes;
  }
  case ANARI_VOLUME: {
    static const char *ANARI_VOLUME_subtypes[] = {"transferFunction1D", 0};
    return ANARI_VOLUME_subtypes;
  }
  default: {
    static const char *none_subtypes[] = {0};
    return none_subtypes;
  }
  }
}
static const void *ANARI_DEVICE_allowInvalidMaterials_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "show surfaces with invalid materials";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_invalidMaterialColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          1.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "color to identify surfaces with invalid materials";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_statusCallback_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "callback used to report information to the application";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_statusCallbackUserData_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "optional pointer passed as the first argument of the status callback";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 0:
    return ANARI_DEVICE_allowInvalidMaterials_info(
        paramType, infoName, infoType);
  case 37:
    return ANARI_DEVICE_invalidMaterialColor_info(
        paramType, infoName, infoType);
  case 47:
    return ANARI_DEVICE_name_info(paramType, infoName, infoType);
  case 72:
    return ANARI_DEVICE_statusCallback_info(paramType, infoName, infoType);
  case 73:
    return ANARI_DEVICE_statusCallbackUserData_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_lightSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(-1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of random light samples per path vertex, per default all light sources are sampled";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_roulettePathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(5)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "ray recursion depth at which to start Russian roulette termination";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxScatteringEvents_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum number of non-specular (i.e., diffuse and glossy) bounces";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "samples are clamped to this value before they are accumulated into the framebuffer";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_backgroundRefraction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "allow for alpha blending even if background is seen through refractive objects like glass";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 55:
    return ANARI_RENDERER_default_pixelSamples_info(
        paramType, infoName, infoType);
  case 43:
    return ANARI_RENDERER_default_maxPathLength_info(
        paramType, infoName, infoType);
  case 46:
    return ANARI_RENDERER_default_minContribution_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_RENDERER_default_varianceThreshold_info(
        paramType, infoName, infoType);
  case 9:
    return ANARI_RENDERER_default_background_info(
        paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_default_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_default_ambientRadiance_info(
        paramType, infoName, infoType);
  case 40:
    return ANARI_RENDERER_default_lightSamples_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_RENDERER_default_roulettePathLength_info(
        paramType, infoName, infoType);
  case 44:
    return ANARI_RENDERER_default_maxScatteringEvents_info(
        paramType, infoName, infoType);
  case 42:
    return ANARI_RENDERER_default_maxContribution_info(
        paramType, infoName, infoType);
  case 10:
    return ANARI_RENDERER_default_backgroundRefraction_info(
        paramType, infoName, infoType);
  case 47:
    return ANARI_RENDERER_default_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_lightSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(-1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of random light samples per path vertex, per default all light sources are sampled";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_roulettePathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(5)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "ray recursion depth at which to start Russian roulette termination";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxScatteringEvents_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum number of non-specular (i.e., diffuse and glossy) bounces";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "samples are clamped to this value before they are accumulated into the framebuffer";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_backgroundRefraction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "allow for alpha blending even if background is seen through refractive objects like glass";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 55:
    return ANARI_RENDERER_pathtracer_pixelSamples_info(
        paramType, infoName, infoType);
  case 43:
    return ANARI_RENDERER_pathtracer_maxPathLength_info(
        paramType, infoName, infoType);
  case 46:
    return ANARI_RENDERER_pathtracer_minContribution_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_RENDERER_pathtracer_varianceThreshold_info(
        paramType, infoName, infoType);
  case 9:
    return ANARI_RENDERER_pathtracer_background_info(
        paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_pathtracer_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_pathtracer_ambientRadiance_info(
        paramType, infoName, infoType);
  case 40:
    return ANARI_RENDERER_pathtracer_lightSamples_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_RENDERER_pathtracer_roulettePathLength_info(
        paramType, infoName, infoType);
  case 44:
    return ANARI_RENDERER_pathtracer_maxScatteringEvents_info(
        paramType, infoName, infoType);
  case 42:
    return ANARI_RENDERER_pathtracer_maxContribution_info(
        paramType, infoName, infoType);
  case 10:
    return ANARI_RENDERER_pathtracer_backgroundRefraction_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_shadows_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "whether to compute (hard) shadows";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_aoSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of rays per sample to compute ambient occlusion";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_aoDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum distance to consider for ambient occlusion";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_volumeSamplingRate_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sampling rate for volumes";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_visibleLights_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "whether light sources are potentially visible (as in the path tracer, regarding each light's visible)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 55:
    return ANARI_RENDERER_scivis_pixelSamples_info(
        paramType, infoName, infoType);
  case 43:
    return ANARI_RENDERER_scivis_maxPathLength_info(
        paramType, infoName, infoType);
  case 46:
    return ANARI_RENDERER_scivis_minContribution_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_RENDERER_scivis_varianceThreshold_info(
        paramType, infoName, infoType);
  case 9:
    return ANARI_RENDERER_scivis_background_info(paramType, infoName, infoType);
  case 69:
    return ANARI_RENDERER_scivis_shadows_info(paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_scivis_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_scivis_ambientRadiance_info(
        paramType, infoName, infoType);
  case 6:
    return ANARI_RENDERER_scivis_aoSamples_info(paramType, infoName, infoType);
  case 5:
    return ANARI_RENDERER_scivis_aoDistance_info(paramType, infoName, infoType);
  case 92:
    return ANARI_RENDERER_scivis_volumeSamplingRate_info(
        paramType, infoName, infoType);
  case 90:
    return ANARI_RENDERER_scivis_visibleLights_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_method_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "which debugging method to use";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"eyeLight",
          "rayDir",
          "Ng",
          "Ns",
          "color",
          "texCoord",
          "backfacing_Ng",
          "backfacing_Ns",
          "dPds",
          "dPdt",
          "primID",
          "geomID",
          "instID",
          "volume",
          "rayDir",
          "testFrame",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 45:
    return ANARI_RENDERER_debug_method_info(paramType, infoName, infoType);
  case 55:
    return ANARI_RENDERER_debug_pixelSamples_info(
        paramType, infoName, infoType);
  case 43:
    return ANARI_RENDERER_debug_maxPathLength_info(
        paramType, infoName, infoType);
  case 46:
    return ANARI_RENDERER_debug_minContribution_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_RENDERER_debug_varianceThreshold_info(
        paramType, infoName, infoType);
  case 9:
    return ANARI_RENDERER_debug_background_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_ARRAY1D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_ARRAY2D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_ARRAY3D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_world_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "world to be rendererd";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_renderer_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "renderer which renders the frame";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_camera_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera used to render the world";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_size_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "size of the frame in pixels (width, height)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_channel_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "enables mapping the color channel as the type specified";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_channel_depth_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "enables mapping the color channel as the type specified";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_FRAME_name_info(paramType, infoName, infoType);
  case 93:
    return ANARI_FRAME_world_info(paramType, infoName, infoType);
  case 67:
    return ANARI_FRAME_renderer_info(paramType, infoName, infoType);
  case 11:
    return ANARI_FRAME_camera_info(paramType, infoName, infoType);
  case 70:
    return ANARI_FRAME_size_info(paramType, infoName, infoType);
  case 13:
    return ANARI_FRAME_channel_color_info(paramType, infoName, infoType);
  case 14:
    return ANARI_FRAME_channel_depth_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_surface_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of surface objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_volume_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of volume objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_VOLUME, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_light_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of light objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_GROUP_name_info(paramType, infoName, infoType);
  case 75:
    return ANARI_GROUP_surface_info(paramType, infoName, infoType);
  case 91:
    return ANARI_GROUP_volume_info(paramType, infoName, infoType);
  case 39:
    return ANARI_GROUP_light_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_INSTANCE_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_INSTANCE_transform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "transform applied to objects in the instance";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_INSTANCE_group_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "group object being instanced";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_INSTANCE_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_INSTANCE_name_info(paramType, infoName, infoType);
  case 76:
    return ANARI_INSTANCE_transform_info(paramType, infoName, infoType);
  case 27:
    return ANARI_INSTANCE_group_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_instance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of instance objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_INSTANCE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_surface_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced surface objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_volume_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced volume objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_light_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced light objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_WORLD_name_info(paramType, infoName, infoType);
  case 34:
    return ANARI_WORLD_instance_info(paramType, infoName, infoType);
  case 75:
    return ANARI_WORLD_surface_info(paramType, infoName, infoType);
  case 91:
    return ANARI_WORLD_volume_info(paramType, infoName, infoType);
  case 39:
    return ANARI_WORLD_light_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_geometry_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "geometry object defining the surface geometry";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_material_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "material object defining the surface appearance";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_SURFACE_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_SURFACE_geometry_info(paramType, infoName, infoType);
  case 41:
    return ANARI_SURFACE_material_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera position";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "main viewing direction";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_up_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera up direction";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_transform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera transform";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_imageRegion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "region mapped to the frame";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_apertureRadius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "aperture radius";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_focusDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "focus distance";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_stereoMode_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "none";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "stereo mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "none", "left", "right", "sideBySide", "topBottom", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_interpupillaryDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.063500f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "interpupillary distance for stereo rendering";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_height_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "height of image plane";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_aspect_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "aspect ratio";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_near_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "near plane clip distance";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_far_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "far plane clip distance";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_CAMERA_orthographic_name_info(paramType, infoName, infoType);
  case 56:
    return ANARI_CAMERA_orthographic_position_info(
        paramType, infoName, infoType);
  case 19:
    return ANARI_CAMERA_orthographic_direction_info(
        paramType, infoName, infoType);
  case 77:
    return ANARI_CAMERA_orthographic_up_info(paramType, infoName, infoType);
  case 76:
    return ANARI_CAMERA_orthographic_transform_info(
        paramType, infoName, infoType);
  case 30:
    return ANARI_CAMERA_orthographic_imageRegion_info(
        paramType, infoName, infoType);
  case 7:
    return ANARI_CAMERA_orthographic_apertureRadius_info(
        paramType, infoName, infoType);
  case 24:
    return ANARI_CAMERA_orthographic_focusDistance_info(
        paramType, infoName, infoType);
  case 74:
    return ANARI_CAMERA_orthographic_stereoMode_info(
        paramType, infoName, infoType);
  case 36:
    return ANARI_CAMERA_orthographic_interpupillaryDistance_info(
        paramType, infoName, infoType);
  case 28:
    return ANARI_CAMERA_orthographic_height_info(paramType, infoName, infoType);
  case 8:
    return ANARI_CAMERA_orthographic_aspect_info(paramType, infoName, infoType);
  case 48:
    return ANARI_CAMERA_orthographic_near_info(paramType, infoName, infoType);
  case 21:
    return ANARI_CAMERA_orthographic_far_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera position";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "main viewing direction";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_up_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera up direction";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_transform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera transform";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_imageRegion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "region mapped to the frame";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_apertureRadius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "aperture radius";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_focusDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "focus distance";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_stereoMode_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "none";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "stereo mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "none", "left", "right", "sideBySide", "topBottom", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_interpupillaryDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.063500f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "interpupillary distance for stereo rendering";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_fovy_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.047198f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertical field of view in radians";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_aspect_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "aspect ratio";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_near_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "near plane clip distance";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_far_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "far plane clip distance";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_CAMERA_perspective_name_info(paramType, infoName, infoType);
  case 56:
    return ANARI_CAMERA_perspective_position_info(
        paramType, infoName, infoType);
  case 19:
    return ANARI_CAMERA_perspective_direction_info(
        paramType, infoName, infoType);
  case 77:
    return ANARI_CAMERA_perspective_up_info(paramType, infoName, infoType);
  case 76:
    return ANARI_CAMERA_perspective_transform_info(
        paramType, infoName, infoType);
  case 30:
    return ANARI_CAMERA_perspective_imageRegion_info(
        paramType, infoName, infoType);
  case 7:
    return ANARI_CAMERA_perspective_apertureRadius_info(
        paramType, infoName, infoType);
  case 24:
    return ANARI_CAMERA_perspective_focusDistance_info(
        paramType, infoName, infoType);
  case 74:
    return ANARI_CAMERA_perspective_stereoMode_info(
        paramType, infoName, infoType);
  case 36:
    return ANARI_CAMERA_perspective_interpupillaryDistance_info(
        paramType, infoName, infoType);
  case 25:
    return ANARI_CAMERA_perspective_fovy_info(paramType, infoName, infoType);
  case 8:
    return ANARI_CAMERA_perspective_aspect_info(paramType, infoName, infoType);
  case 48:
    return ANARI_CAMERA_perspective_near_info(paramType, infoName, infoType);
  case 21:
    return ANARI_CAMERA_perspective_far_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_cap_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex cap type";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_caps_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "none";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cap type";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "none", "first", "second", "both", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_GEOMETRY_cone_name_info(paramType, infoName, infoType);
  case 62:
    return ANARI_GEOMETRY_cone_primitive_color_info(
        paramType, infoName, infoType);
  case 58:
    return ANARI_GEOMETRY_cone_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 59:
    return ANARI_GEOMETRY_cone_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_GEOMETRY_cone_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 61:
    return ANARI_GEOMETRY_cone_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_GEOMETRY_cone_primitive_id_info(paramType, infoName, infoType);
  case 87:
    return ANARI_GEOMETRY_cone_vertex_position_info(
        paramType, infoName, infoType);
  case 88:
    return ANARI_GEOMETRY_cone_vertex_radius_info(
        paramType, infoName, infoType);
  case 84:
    return ANARI_GEOMETRY_cone_vertex_cap_info(paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_cone_vertex_color_info(paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_cone_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_cone_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_cone_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_cone_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_GEOMETRY_cone_primitive_index_info(
        paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_cone_caps_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global radius";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_GEOMETRY_curve_name_info(paramType, infoName, infoType);
  case 62:
    return ANARI_GEOMETRY_curve_primitive_color_info(
        paramType, infoName, infoType);
  case 58:
    return ANARI_GEOMETRY_curve_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 59:
    return ANARI_GEOMETRY_curve_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_GEOMETRY_curve_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 61:
    return ANARI_GEOMETRY_curve_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_GEOMETRY_curve_primitive_id_info(
        paramType, infoName, infoType);
  case 87:
    return ANARI_GEOMETRY_curve_vertex_position_info(
        paramType, infoName, infoType);
  case 88:
    return ANARI_GEOMETRY_curve_vertex_radius_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_curve_vertex_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_curve_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_curve_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_curve_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_curve_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_GEOMETRY_curve_primitive_index_info(
        paramType, infoName, infoType);
  case 66:
    return ANARI_GEOMETRY_curve_radius_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_cap_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cylinder cap type";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cylinder radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cylinder radius";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_caps_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "none";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cylinder cap type";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "none", "first", "second", "both", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_GEOMETRY_cylinder_name_info(paramType, infoName, infoType);
  case 62:
    return ANARI_GEOMETRY_cylinder_primitive_color_info(
        paramType, infoName, infoType);
  case 58:
    return ANARI_GEOMETRY_cylinder_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 59:
    return ANARI_GEOMETRY_cylinder_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_GEOMETRY_cylinder_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 61:
    return ANARI_GEOMETRY_cylinder_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_GEOMETRY_cylinder_primitive_id_info(
        paramType, infoName, infoType);
  case 87:
    return ANARI_GEOMETRY_cylinder_vertex_position_info(
        paramType, infoName, infoType);
  case 84:
    return ANARI_GEOMETRY_cylinder_vertex_cap_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_cylinder_vertex_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_cylinder_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_cylinder_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_cylinder_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_cylinder_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_GEOMETRY_cylinder_primitive_index_info(
        paramType, infoName, infoType);
  case 65:
    return ANARI_GEOMETRY_cylinder_primitive_radius_info(
        paramType, infoName, infoType);
  case 66:
    return ANARI_GEOMETRY_cylinder_radius_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_cylinder_caps_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_tangent_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3,
          ANARI_FIXED16_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_FIXED16_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC4, ANARI_UINT64_VEC4, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_GEOMETRY_quad_name_info(paramType, infoName, infoType);
  case 62:
    return ANARI_GEOMETRY_quad_primitive_color_info(
        paramType, infoName, infoType);
  case 58:
    return ANARI_GEOMETRY_quad_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 59:
    return ANARI_GEOMETRY_quad_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_GEOMETRY_quad_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 61:
    return ANARI_GEOMETRY_quad_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_GEOMETRY_quad_primitive_id_info(paramType, infoName, infoType);
  case 87:
    return ANARI_GEOMETRY_quad_vertex_position_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_quad_vertex_normal_info(
        paramType, infoName, infoType);
  case 89:
    return ANARI_GEOMETRY_quad_vertex_tangent_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_quad_vertex_color_info(paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_quad_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_quad_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_quad_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_quad_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_GEOMETRY_quad_primitive_index_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sphere position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sphere radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global sphere radius";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_GEOMETRY_sphere_name_info(paramType, infoName, infoType);
  case 62:
    return ANARI_GEOMETRY_sphere_primitive_color_info(
        paramType, infoName, infoType);
  case 58:
    return ANARI_GEOMETRY_sphere_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 59:
    return ANARI_GEOMETRY_sphere_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_GEOMETRY_sphere_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 61:
    return ANARI_GEOMETRY_sphere_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_GEOMETRY_sphere_primitive_id_info(
        paramType, infoName, infoType);
  case 87:
    return ANARI_GEOMETRY_sphere_vertex_position_info(
        paramType, infoName, infoType);
  case 88:
    return ANARI_GEOMETRY_sphere_vertex_radius_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_sphere_vertex_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_sphere_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_sphere_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_sphere_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_sphere_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_GEOMETRY_sphere_primitive_index_info(
        paramType, infoName, infoType);
  case 66:
    return ANARI_GEOMETRY_sphere_radius_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_tangent_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3,
          ANARI_FIXED16_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_FIXED16_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC3, ANARI_UINT64_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_GEOMETRY_triangle_name_info(paramType, infoName, infoType);
  case 62:
    return ANARI_GEOMETRY_triangle_primitive_color_info(
        paramType, infoName, infoType);
  case 58:
    return ANARI_GEOMETRY_triangle_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 59:
    return ANARI_GEOMETRY_triangle_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_GEOMETRY_triangle_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 61:
    return ANARI_GEOMETRY_triangle_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_GEOMETRY_triangle_primitive_id_info(
        paramType, infoName, infoType);
  case 87:
    return ANARI_GEOMETRY_triangle_vertex_position_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_triangle_vertex_normal_info(
        paramType, infoName, infoType);
  case 89:
    return ANARI_GEOMETRY_triangle_vertex_tangent_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_triangle_vertex_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_triangle_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_triangle_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_triangle_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_triangle_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_GEOMETRY_triangle_primitive_index_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_DIRECTIONAL";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_DIRECTIONAL";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_irradiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "amount of light in W/m^2";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_DIRECTIONAL";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "emission direction of the light";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_DIRECTIONAL";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_LIGHT_directional_name_info(paramType, infoName, infoType);
  case 15:
    return ANARI_LIGHT_directional_color_info(paramType, infoName, infoType);
  case 38:
    return ANARI_LIGHT_directional_irradiance_info(
        paramType, infoName, infoType);
  case 19:
    return ANARI_LIGHT_directional_direction_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_POINT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_POINT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_POINT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_POINT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_POINT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_LIGHT_point_name_info(paramType, infoName, infoType);
  case 15:
    return ANARI_LIGHT_point_color_info(paramType, infoName, infoType);
  case 56:
    return ANARI_LIGHT_point_position_info(paramType, infoName, infoType);
  case 35:
    return ANARI_LIGHT_point_intensity_info(paramType, infoName, infoType);
  case 57:
    return ANARI_LIGHT_point_power_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_SPOT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_SPOT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_SPOT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "the axis of the spot";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_SPOT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_openingAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {3.141593f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opening angle in radians";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_SPOT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_falloffAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.100000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "falloff angle in radians";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_SPOT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_SPOT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_SPOT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_LIGHT_spot_name_info(paramType, infoName, infoType);
  case 15:
    return ANARI_LIGHT_spot_color_info(paramType, infoName, infoType);
  case 56:
    return ANARI_LIGHT_spot_position_info(paramType, infoName, infoType);
  case 19:
    return ANARI_LIGHT_spot_direction_info(paramType, infoName, infoType);
  case 51:
    return ANARI_LIGHT_spot_openingAngle_info(paramType, infoName, infoType);
  case 20:
    return ANARI_LIGHT_spot_falloffAngle_info(paramType, infoName, infoType);
  case 35:
    return ANARI_LIGHT_spot_intensity_info(paramType, infoName, infoType);
  case 57:
    return ANARI_LIGHT_spot_power_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_MATERIAL_MATTE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.800000f, 0.800000f, 0.800000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "diffuse color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_MATERIAL_MATTE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opacity";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_MATERIAL_MATTE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_alphaMode_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "opaque";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "alpha mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"opaque", "blend", "mask", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_MATERIAL_MATTE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_alphaCutoff_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cutoff for alpha mask mode";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_MATERIAL_MATTE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_MATERIAL_matte_name_info(paramType, infoName, infoType);
  case 15:
    return ANARI_MATERIAL_matte_color_info(paramType, infoName, infoType);
  case 49:
    return ANARI_MATERIAL_matte_opacity_info(paramType, infoName, infoType);
  case 2:
    return ANARI_MATERIAL_matte_alphaMode_info(paramType, infoName, infoType);
  case 1:
    return ANARI_MATERIAL_matte_alphaCutoff_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_image_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array backing the sampler";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inAttribute_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "attribute0";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "input surface attribute (texture coordinate)";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "nearest";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_wrapMode1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 1st dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "transform applied to the input attribute before sampling";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output inTransform result";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_outTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transform applied to the sampled values";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_outOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output outTransform result";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_SAMPLER_image1D_name_info(paramType, infoName, infoType);
  case 29:
    return ANARI_SAMPLER_image1D_image_info(paramType, infoName, infoType);
  case 31:
    return ANARI_SAMPLER_image1D_inAttribute_info(
        paramType, infoName, infoType);
  case 23:
    return ANARI_SAMPLER_image1D_filter_info(paramType, infoName, infoType);
  case 94:
    return ANARI_SAMPLER_image1D_wrapMode1_info(paramType, infoName, infoType);
  case 33:
    return ANARI_SAMPLER_image1D_inTransform_info(
        paramType, infoName, infoType);
  case 32:
    return ANARI_SAMPLER_image1D_inOffset_info(paramType, infoName, infoType);
  case 54:
    return ANARI_SAMPLER_image1D_outTransform_info(
        paramType, infoName, infoType);
  case 53:
    return ANARI_SAMPLER_image1D_outOffset_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_image_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array backing the sampler";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inAttribute_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "attribute0";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "input surface attribute (texture coordinate)";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "nearest";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_wrapMode1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 1st dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_wrapMode2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 2nd dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "transform applied to the input attribute before sampling";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output inTransform result";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_outTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transform applied to the sampled values";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_outOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output outTransform result";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_SAMPLER_image2D_name_info(paramType, infoName, infoType);
  case 29:
    return ANARI_SAMPLER_image2D_image_info(paramType, infoName, infoType);
  case 31:
    return ANARI_SAMPLER_image2D_inAttribute_info(
        paramType, infoName, infoType);
  case 23:
    return ANARI_SAMPLER_image2D_filter_info(paramType, infoName, infoType);
  case 94:
    return ANARI_SAMPLER_image2D_wrapMode1_info(paramType, infoName, infoType);
  case 95:
    return ANARI_SAMPLER_image2D_wrapMode2_info(paramType, infoName, infoType);
  case 33:
    return ANARI_SAMPLER_image2D_inTransform_info(
        paramType, infoName, infoType);
  case 32:
    return ANARI_SAMPLER_image2D_inOffset_info(paramType, infoName, infoType);
  case 54:
    return ANARI_SAMPLER_image2D_outTransform_info(
        paramType, infoName, infoType);
  case 53:
    return ANARI_SAMPLER_image2D_outOffset_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_data_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of vertex centered scalar values";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8,
          ANARI_INT16,
          ANARI_UINT16,
          ANARI_FLOAT32,
          ANARI_FLOAT64,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_origin_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "origin of the grid in object-space";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "size of the grid cells in object-space";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "linear";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode used to interpolate the grid";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_SPATIAL_FIELD_structuredRegular_name_info(
        paramType, infoName, infoType);
  case 17:
    return ANARI_SPATIAL_FIELD_structuredRegular_data_info(
        paramType, infoName, infoType);
  case 52:
    return ANARI_SPATIAL_FIELD_structuredRegular_origin_info(
        paramType, infoName, infoType);
  case 71:
    return ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(
        paramType, infoName, infoType);
  case 23:
    return ANARI_SPATIAL_FIELD_structuredRegular_filter_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_field_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "spatial field used for the field values of the volume";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_valueRange_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
      static const float default_value[2] = {0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sampled values of field are clamped to this range";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array to map sampled and clamped field values to color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_color_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "optional array to position the elements of color values in valueRange";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array to map sampled and clamped field values to opacity";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_opacity_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "optional array to position the elements of opacity values in valueRange";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_densityScale_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "makes volumes uniformly thinner or thicker";
    return description;
  }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 47:
    return ANARI_VOLUME_transferFunction1D_name_info(
        paramType, infoName, infoType);
  case 22:
    return ANARI_VOLUME_transferFunction1D_field_info(
        paramType, infoName, infoType);
  case 78:
    return ANARI_VOLUME_transferFunction1D_valueRange_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_VOLUME_transferFunction1D_color_info(
        paramType, infoName, infoType);
  case 16:
    return ANARI_VOLUME_transferFunction1D_color_position_info(
        paramType, infoName, infoType);
  case 49:
    return ANARI_VOLUME_transferFunction1D_opacity_info(
        paramType, infoName, infoType);
  case 50:
    return ANARI_VOLUME_transferFunction1D_opacity_position_info(
        paramType, infoName, infoType);
  case 18:
    return ANARI_VOLUME_transferFunction1D_densityScale_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 9:
    return ANARI_CAMERA_orthographic_param_info(
        paramName, paramType, infoName, infoType);
  case 11:
    return ANARI_CAMERA_perspective_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 0:
    return ANARI_GEOMETRY_cone_param_info(
        paramName, paramType, infoName, infoType);
  case 1:
    return ANARI_GEOMETRY_curve_param_info(
        paramName, paramType, infoName, infoType);
  case 2:
    return ANARI_GEOMETRY_cylinder_param_info(
        paramName, paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_quad_param_info(
        paramName, paramType, infoName, infoType);
  case 15:
    return ANARI_GEOMETRY_sphere_param_info(
        paramName, paramType, infoName, infoType);
  case 19:
    return ANARI_GEOMETRY_triangle_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 5:
    return ANARI_LIGHT_directional_param_info(
        paramName, paramType, infoName, infoType);
  case 12:
    return ANARI_LIGHT_point_param_info(
        paramName, paramType, infoName, infoType);
  case 16:
    return ANARI_LIGHT_spot_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 8:
    return ANARI_MATERIAL_matte_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 4:
    return ANARI_RENDERER_default_param_info(
        paramName, paramType, infoName, infoType);
  case 10:
    return ANARI_RENDERER_pathtracer_param_info(
        paramName, paramType, infoName, infoType);
  case 14:
    return ANARI_RENDERER_scivis_param_info(
        paramName, paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_debug_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 6:
    return ANARI_SAMPLER_image1D_param_info(
        paramName, paramType, infoName, infoType);
  case 7:
    return ANARI_SAMPLER_image2D_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 17:
    return ANARI_SPATIAL_FIELD_structuredRegular_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 18:
    return ANARI_VOLUME_transferFunction1D_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_param_info_enum(ANARIDataType type,
    const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (type) {
  case ANARI_CAMERA:
    return ANARI_CAMERA_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_GEOMETRY:
    return ANARI_GEOMETRY_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_LIGHT:
    return ANARI_LIGHT_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_MATERIAL:
    return ANARI_MATERIAL_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_RENDERER:
    return ANARI_RENDERER_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_SAMPLER:
    return ANARI_SAMPLER_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_SPATIAL_FIELD:
    return ANARI_SPATIAL_FIELD_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_VOLUME:
    return ANARI_VOLUME_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_DEVICE:
    return ANARI_DEVICE_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY1D:
    return ANARI_ARRAY1D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY2D:
    return ANARI_ARRAY2D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY3D:
    return ANARI_ARRAY3D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_FRAME:
    return ANARI_FRAME_param_info(paramName, paramType, infoName, infoType);
  case ANARI_GROUP:
    return ANARI_GROUP_param_info(paramName, paramType, infoName, infoType);
  case ANARI_INSTANCE:
    return ANARI_INSTANCE_param_info(paramName, paramType, infoName, infoType);
  case ANARI_WORLD:
    return ANARI_WORLD_param_info(paramName, paramType, infoName, infoType);
  case ANARI_SURFACE:
    return ANARI_SURFACE_param_info(paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_param_info(ANARIDataType type,
    const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    const char *infoNameString,
    ANARIDataType infoType)
{
  int infoName = info_hash(infoNameString);
  return query_param_info_enum(
      type, subtype, paramName, paramType, infoName, infoType);
}
static const void *ANARI_DEVICE_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "device object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"allowInvalidMaterials", ANARI_BOOL},
          {"invalidMaterialColor", ANARI_FLOAT32_VEC4},
          {"name", ANARI_STRING},
          {"statusCallback", ANARI_STATUS_CALLBACK},
          {"statusCallbackUserData", ANARI_VOID_POINTER},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 8: // feature
    if (infoType == ANARI_STRING_LIST) {
      static const char *features[] = {"ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          0};
      return features;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The path tracer supports soft shadows, indirect illumination and realistic materials.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"lightSamples", ANARI_INT32},
          {"roulettePathLength", ANARI_INT32},
          {"maxScatteringEvents", ANARI_INT32},
          {"maxContribution", ANARI_FLOAT32},
          {"backgroundRefraction", ANARI_BOOL},
          {"name", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 8: // feature
    if (infoType == ANARI_STRING_LIST) {
      static const char *features[] = {"ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          0};
      return features;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The path tracer supports soft shadows, indirect illumination and realistic materials.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"lightSamples", ANARI_INT32},
          {"roulettePathLength", ANARI_INT32},
          {"maxScatteringEvents", ANARI_INT32},
          {"maxContribution", ANARI_FLOAT32},
          {"backgroundRefraction", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 8: // feature
    if (infoType == ANARI_STRING_LIST) {
      static const char *features[] = {"ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          0};
      return features;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The SciVis renderer is a fast ray tracer for scientific visualization which supports volume rendering and ambient occlusion (AO).";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"shadows", ANARI_BOOL},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"aoSamples", ANARI_INT32},
          {"aoDistance", ANARI_FLOAT32},
          {"volumeSamplingRate", ANARI_FLOAT32},
          {"visibleLights", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 8: // feature
    if (infoType == ANARI_STRING_LIST) {
      static const char *features[] = {"ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          0};
      return features;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "This renderer is used for debugging the underlying OSPRay system.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"method", ANARI_STRING},
          {"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 8: // feature
    if (infoType == ANARI_STRING_LIST) {
      static const char *features[] = {"ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          0};
      return features;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "one dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "two dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "three dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "frame object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"world", ANARI_WORLD},
          {"renderer", ANARI_RENDERER},
          {"camera", ANARI_CAMERA},
          {"size", ANARI_UINT32_VEC2},
          {"channel.color", ANARI_DATA_TYPE},
          {"channel.depth", ANARI_DATA_TYPE},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 10: // channel
    if (infoType == ANARI_STRING_LIST) {
      static const char *channel[] = {"channel.color", "channel.depth", 0};
      return channel;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "group object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"surface", ANARI_ARRAY1D},
          {"volume", ANARI_ARRAY1D},
          {"light", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_INSTANCE_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "instance object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"transform", ANARI_FLOAT32_MAT4},
          {"group", ANARI_GROUP},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "world object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"instance", ANARI_ARRAY1D},
          {"surface", ANARI_ARRAY1D},
          {"volume", ANARI_ARRAY1D},
          {"light", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "surface object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"geometry", ANARI_GEOMETRY},
          {"material", ANARI_MATERIAL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "orthographic camera object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"up", ANARI_FLOAT32_VEC3},
          {"transform", ANARI_FLOAT32_MAT4},
          {"imageRegion", ANARI_FLOAT32_BOX2},
          {"apertureRadius", ANARI_FLOAT32},
          {"focusDistance", ANARI_FLOAT32},
          {"stereoMode", ANARI_STRING},
          {"interpupillaryDistance", ANARI_FLOAT32},
          {"height", ANARI_FLOAT32},
          {"aspect", ANARI_FLOAT32},
          {"near", ANARI_FLOAT32},
          {"far", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 0;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "perspective camera object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"up", ANARI_FLOAT32_VEC3},
          {"transform", ANARI_FLOAT32_MAT4},
          {"imageRegion", ANARI_FLOAT32_BOX2},
          {"apertureRadius", ANARI_FLOAT32},
          {"focusDistance", ANARI_FLOAT32},
          {"stereoMode", ANARI_STRING},
          {"interpupillaryDistance", ANARI_FLOAT32},
          {"fovy", ANARI_FLOAT32},
          {"aspect", ANARI_FLOAT32},
          {"near", ANARI_FLOAT32},
          {"far", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_CAMERA_PERSPECTIVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 1;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "cone geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.cap", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"caps", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CONE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 2;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "curve geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CURVE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 3;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "cylinder geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.cap", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"primitive.radius", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {"caps", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_CYLINDER";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 4;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "quad geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.normal", ANARI_ARRAY1D},
          {"vertex.tangent", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_QUAD";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 5;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "sphere geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_SPHERE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 6;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "triangle geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.normal", ANARI_ARRAY1D},
          {"vertex.tangent", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_GEOMETRY_TRIANGLE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 7;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "directional light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"irradiance", ANARI_FLOAT32},
          {"direction", ANARI_FLOAT32_VEC3},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_DIRECTIONAL";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 8;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "point light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_POINT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 9;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "spot light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"openingAngle", ANARI_FLOAT32},
          {"falloffAngle", ANARI_FLOAT32},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_LIGHT_SPOT";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 10;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "matte material object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"color", ANARI_SAMPLER},
          {"color", ANARI_STRING},
          {"opacity", ANARI_FLOAT32},
          {"opacity", ANARI_SAMPLER},
          {"opacity", ANARI_STRING},
          {"alphaMode", ANARI_STRING},
          {"alphaCutoff", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_MATERIAL_MATTE";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 11;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "image1D object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"image", ANARI_ARRAY1D},
          {"inAttribute", ANARI_STRING},
          {"filter", ANARI_STRING},
          {"wrapMode1", ANARI_STRING},
          {"inTransform", ANARI_FLOAT32_MAT4},
          {"inOffset", ANARI_FLOAT32_VEC4},
          {"outTransform", ANARI_FLOAT32_MAT4},
          {"outOffset", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 12;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "image2D object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"image", ANARI_ARRAY2D},
          {"inAttribute", ANARI_STRING},
          {"filter", ANARI_STRING},
          {"wrapMode1", ANARI_STRING},
          {"wrapMode2", ANARI_STRING},
          {"inTransform", ANARI_FLOAT32_MAT4},
          {"inOffset", ANARI_FLOAT32_VEC4},
          {"outTransform", ANARI_FLOAT32_MAT4},
          {"outOffset", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SAMPLER_IMAGE2D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 13;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "structured regular spatial field object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"data", ANARI_ARRAY3D},
          {"origin", ANARI_FLOAT32_VEC3},
          {"spacing", ANARI_FLOAT32_VEC3},
          {"filter", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 14;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "transferFunction1D volume object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"field", ANARI_SPATIAL_FIELD},
          {"valueRange", ANARI_FLOAT32_BOX1},
          {"valueRange", ANARI_FLOAT64_BOX1},
          {"color", ANARI_ARRAY1D},
          {"color.position", ANARI_ARRAY1D},
          {"opacity", ANARI_ARRAY1D},
          {"opacity.position", ANARI_ARRAY1D},
          {"densityScale", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceFeature
    if (infoType == ANARI_STRING) {
      static const char *feature = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return feature;
    } else if (infoType == ANARI_INT32) {
      static const int value = 15;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 9:
    return ANARI_CAMERA_orthographic_info(infoName, infoType);
  case 11:
    return ANARI_CAMERA_perspective_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 0:
    return ANARI_GEOMETRY_cone_info(infoName, infoType);
  case 1:
    return ANARI_GEOMETRY_curve_info(infoName, infoType);
  case 2:
    return ANARI_GEOMETRY_cylinder_info(infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_quad_info(infoName, infoType);
  case 15:
    return ANARI_GEOMETRY_sphere_info(infoName, infoType);
  case 19:
    return ANARI_GEOMETRY_triangle_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 5:
    return ANARI_LIGHT_directional_info(infoName, infoType);
  case 12:
    return ANARI_LIGHT_point_info(infoName, infoType);
  case 16:
    return ANARI_LIGHT_spot_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 8:
    return ANARI_MATERIAL_matte_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 4:
    return ANARI_RENDERER_default_info(infoName, infoType);
  case 10:
    return ANARI_RENDERER_pathtracer_info(infoName, infoType);
  case 14:
    return ANARI_RENDERER_scivis_info(infoName, infoType);
  case 3:
    return ANARI_RENDERER_debug_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 6:
    return ANARI_SAMPLER_image1D_info(infoName, infoType);
  case 7:
    return ANARI_SAMPLER_image2D_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 17:
    return ANARI_SPATIAL_FIELD_structuredRegular_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 18:
    return ANARI_VOLUME_transferFunction1D_info(infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_object_info_enum(ANARIDataType type,
    const char *subtype,
    int infoName,
    ANARIDataType infoType)
{
  switch (type) {
  case ANARI_CAMERA:
    return ANARI_CAMERA_info(subtype, infoName, infoType);
  case ANARI_GEOMETRY:
    return ANARI_GEOMETRY_info(subtype, infoName, infoType);
  case ANARI_LIGHT:
    return ANARI_LIGHT_info(subtype, infoName, infoType);
  case ANARI_MATERIAL:
    return ANARI_MATERIAL_info(subtype, infoName, infoType);
  case ANARI_RENDERER:
    return ANARI_RENDERER_info(subtype, infoName, infoType);
  case ANARI_SAMPLER:
    return ANARI_SAMPLER_info(subtype, infoName, infoType);
  case ANARI_SPATIAL_FIELD:
    return ANARI_SPATIAL_FIELD_info(subtype, infoName, infoType);
  case ANARI_VOLUME:
    return ANARI_VOLUME_info(subtype, infoName, infoType);
  case ANARI_DEVICE:
    return ANARI_DEVICE_info(infoName, infoType);
  case ANARI_ARRAY1D:
    return ANARI_ARRAY1D_info(infoName, infoType);
  case ANARI_ARRAY2D:
    return ANARI_ARRAY2D_info(infoName, infoType);
  case ANARI_ARRAY3D:
    return ANARI_ARRAY3D_info(infoName, infoType);
  case ANARI_FRAME:
    return ANARI_FRAME_info(infoName, infoType);
  case ANARI_GROUP:
    return ANARI_GROUP_info(infoName, infoType);
  case ANARI_INSTANCE:
    return ANARI_INSTANCE_info(infoName, infoType);
  case ANARI_WORLD:
    return ANARI_WORLD_info(infoName, infoType);
  case ANARI_SURFACE:
    return ANARI_SURFACE_info(infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_object_info(ANARIDataType type,
    const char *subtype,
    const char *infoNameString,
    ANARIDataType infoType)
{
  int infoName = info_hash(infoNameString);
  return query_object_info_enum(type, subtype, infoName, infoType);
}
} // namespace anari_ospray
