// Copyright 2024 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_queries.py
// Don't make changes to this directly

#include <anari/anari.h>
#include <math.h>
#include <stdint.h>
namespace anari_ospray {
static int subtype_hash(const char *str)
{
  static const uint32_t table[] = {0x7a6f0012u,
      0x6a65002bu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6e6d0047u,
      0x0u,
      0x0u,
      0x0u,
      0x62610051u,
      0x0u,
      0x73720056u,
      0x70610062u,
      0x76750096u,
      0x0u,
      0x7563009au,
      0x737200cfu,
      0x6f6e001du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720020u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c0024u,
      0x6665001eu,
      0x100001fu,
      0x80000000u,
      0x77760021u,
      0x66650022u,
      0x1000023u,
      0x80000001u,
      0x6a690025u,
      0x6f6e0026u,
      0x65640027u,
      0x66650028u,
      0x73720029u,
      0x100002au,
      0x80000002u,
      0x67620030u,
      0x0u,
      0x0u,
      0x0u,
      0x7372003du,
      0x76750035u,
      0x0u,
      0x0u,
      0x0u,
      0x62610038u,
      0x68670036u,
      0x1000037u,
      0x80000003u,
      0x76750039u,
      0x6d6c003au,
      0x7574003bu,
      0x100003cu,
      0x80000004u,
      0x6665003eu,
      0x6463003fu,
      0x75740040u,
      0x6a690041u,
      0x706f0042u,
      0x6f6e0043u,
      0x62610044u,
      0x6d6c0045u,
      0x1000046u,
      0x80000005u,
      0x62610048u,
      0x68670049u,
      0x6665004au,
      0x3331004bu,
      0x4544004du,
      0x4544004fu,
      0x100004eu,
      0x80000006u,
      0x1000050u,
      0x80000007u,
      0x75740052u,
      0x75740053u,
      0x66650054u,
      0x1000055u,
      0x80000008u,
      0x75740057u,
      0x69680058u,
      0x706f0059u,
      0x6867005au,
      0x7372005bu,
      0x6261005cu,
      0x7170005du,
      0x6968005eu,
      0x6a69005fu,
      0x64630060u,
      0x1000061u,
      0x80000009u,
      0x75740071u,
      0x0u,
      0x0u,
      0x0u,
      0x7372007au,
      0x0u,
      0x0u,
      0x7a790084u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a690092u,
      0x69680072u,
      0x75740073u,
      0x73720074u,
      0x62610075u,
      0x64630076u,
      0x66650077u,
      0x73720078u,
      0x1000079u,
      0x8000000au,
      0x7473007bu,
      0x7170007cu,
      0x6665007du,
      0x6463007eu,
      0x7574007fu,
      0x6a690080u,
      0x77760081u,
      0x66650082u,
      0x1000083u,
      0x8000000bu,
      0x74730085u,
      0x6a690086u,
      0x64630087u,
      0x62610088u,
      0x6d6c0089u,
      0x6d6c008au,
      0x7a79008bu,
      0x4342008cu,
      0x6261008du,
      0x7473008eu,
      0x6665008fu,
      0x65640090u,
      0x1000091u,
      0x8000000cu,
      0x6f6e0093u,
      0x75740094u,
      0x1000095u,
      0x8000000du,
      0x62610097u,
      0x65640098u,
      0x1000099u,
      0x8000000eu,
      0x6a6900acu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706800b1u,
      0x0u,
      0x0u,
      0x0u,
      0x737200bfu,
      0x777600adu,
      0x6a6900aeu,
      0x747300afu,
      0x10000b0u,
      0x8000000fu,
      0x666500b9u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x757400bdu,
      0x737200bau,
      0x666500bbu,
      0x10000bcu,
      0x80000010u,
      0x10000beu,
      0x80000011u,
      0x767500c0u,
      0x646300c1u,
      0x757400c2u,
      0x767500c3u,
      0x737200c4u,
      0x666500c5u,
      0x656400c6u,
      0x535200c7u,
      0x666500c8u,
      0x686700c9u,
      0x767500cau,
      0x6d6c00cbu,
      0x626100ccu,
      0x737200cdu,
      0x10000ceu,
      0x80000012u,
      0x6a6100d0u,
      0x6f6e00d9u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626100e9u,
      0x747300dau,
      0x676600dbu,
      0x666500dcu,
      0x737200ddu,
      0x474600deu,
      0x767500dfu,
      0x6f6e00e0u,
      0x646300e1u,
      0x757400e2u,
      0x6a6900e3u,
      0x706f00e4u,
      0x6f6e00e5u,
      0x323100e6u,
      0x454400e7u,
      0x10000e8u,
      0x80000013u,
      0x6f6e00eau,
      0x686700ebu,
      0x6d6c00ecu,
      0x666500edu,
      0x10000eeu,
      0x80000014u};
  uint32_t cur = 0x75630000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static int param_hash(const char *str)
{
  static const uint32_t table[] = {0x756c0017u,
      0x626100c7u,
      0x70610144u,
      0x6a6101dcu,
      0x6e6d01f0u,
      0x706101f8u,
      0x66650221u,
      0x66650229u,
      0x736d022fu,
      0x0u,
      0x0u,
      0x6a69037bu,
      0x6a6103dau,
      0x70610444u,
      0x7663045eu,
      0x736904a8u,
      0x0u,
      0x70610510u,
      0x76680547u,
      0x7368064au,
      0x716e0668u,
      0x70610677u,
      0x736f07bfu,
      0x716c0020u,
      0x6362004fu,
      0x0u,
      0x54440071u,
      0x0u,
      0x0u,
      0x0u,
      0x71700090u,
      0x75740095u,
      0x706f0025u,
      0x0u,
      0x0u,
      0x0u,
      0x69680038u,
      0x78770026u,
      0x4a490027u,
      0x6f6e0028u,
      0x77760029u,
      0x6261002au,
      0x6d6c002bu,
      0x6a69002cu,
      0x6564002du,
      0x4e4d002eu,
      0x6261002fu,
      0x75740030u,
      0x66650031u,
      0x73720032u,
      0x6a690033u,
      0x62610034u,
      0x6d6c0035u,
      0x74730036u,
      0x1000037u,
      0x80000000u,
      0x62610039u,
      0x4e43003au,
      0x76750045u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f004bu,
      0x75740046u,
      0x706f0047u,
      0x67660048u,
      0x67660049u,
      0x100004au,
      0x80000001u,
      0x6564004cu,
      0x6665004du,
      0x100004eu,
      0x80000002u,
      0x6a690050u,
      0x66650051u,
      0x6f6e0052u,
      0x75740053u,
      0x53430054u,
      0x706f0064u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610069u,
      0x6d6c0065u,
      0x706f0066u,
      0x73720067u,
      0x1000068u,
      0x80000003u,
      0x6564006au,
      0x6a69006bu,
      0x6261006cu,
      0x6f6e006du,
      0x6463006eu,
      0x6665006fu,
      0x1000070u,
      0x80000004u,
      0x6a690081u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610089u,
      0x74730082u,
      0x75740083u,
      0x62610084u,
      0x6f6e0085u,
      0x64630086u,
      0x66650087u,
      0x1000088u,
      0x80000005u,
      0x6e6d008au,
      0x7170008bu,
      0x6d6c008cu,
      0x6665008du,
      0x7473008eu,
      0x100008fu,
      0x80000006u,
      0x66650091u,
      0x64630092u,
      0x75740093u,
      0x1000094u,
      0x80000007u,
      0x73650096u,
      0x6f6e00a4u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a6900bau,
      0x767500a5u,
      0x626100a6u,
      0x757400a7u,
      0x6a6900a8u,
      0x706f00a9u,
      0x6f6e00aau,
      0x454300abu,
      0x706f00adu,
      0x6a6900b2u,
      0x6d6c00aeu,
      0x706f00afu,
      0x737200b0u,
      0x10000b1u,
      0x80000008u,
      0x747300b3u,
      0x757400b4u,
      0x626100b5u,
      0x6f6e00b6u,
      0x646300b7u,
      0x666500b8u,
      0x10000b9u,
      0x80000009u,
      0x636200bbu,
      0x767500bcu,
      0x757400bdu,
      0x666500beu,
      0x343000bfu,
      0x10000c3u,
      0x10000c4u,
      0x10000c5u,
      0x10000c6u,
      0x8000000au,
      0x8000000bu,
      0x8000000cu,
      0x8000000du,
      0x746300c8u,
      0x6c6b00d9u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6665013du,
      0x686700dau,
      0x737200dbu,
      0x706f00dcu,
      0x767500ddu,
      0x6f6e00deu,
      0x656400dfu,
      0x530000e0u,
      0x8000000eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66650133u,
      0x67660134u,
      0x73720135u,
      0x62610136u,
      0x64630137u,
      0x75740138u,
      0x6a690139u,
      0x706f013au,
      0x6f6e013bu,
      0x100013cu,
      0x8000000fu,
      0x4443013eu,
      0x706f013fu,
      0x6d6c0140u,
      0x706f0141u,
      0x73720142u,
      0x1000143u,
      0x80000010u,
      0x716d0153u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6261015du,
      0x0u,
      0x0u,
      0x0u,
      0x6665016fu,
      0x0u,
      0x0u,
      0x6d6c01d8u,
      0x66650157u,
      0x0u,
      0x0u,
      0x7473015bu,
      0x73720158u,
      0x62610159u,
      0x100015au,
      0x80000011u,
      0x100015cu,
      0x80000012u,
      0x6f6e015eu,
      0x6f6e015fu,
      0x66650160u,
      0x6d6c0161u,
      0x2f2e0162u,
      0x65630163u,
      0x706f0165u,
      0x6665016au,
      0x6d6c0166u,
      0x706f0167u,
      0x73720168u,
      0x1000169u,
      0x80000013u,
      0x7170016bu,
      0x7574016cu,
      0x6968016du,
      0x100016eu,
      0x80000014u,
      0x62610170u,
      0x73720171u,
      0x64630172u,
      0x706f0173u,
      0x62610174u,
      0x75740175u,
      0x53000176u,
      0x80000015u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f01c9u,
      0x0u,
      0x0u,
      0x0u,
      0x706f01cfu,
      0x737201cau,
      0x6e6d01cbu,
      0x626101ccu,
      0x6d6c01cdu,
      0x10001ceu,
      0x80000016u,
      0x767501d0u,
      0x686701d1u,
      0x696801d2u,
      0x6f6e01d3u,
      0x666501d4u,
      0x747301d5u,
      0x747301d6u,
      0x10001d7u,
      0x80000017u,
      0x706f01d9u,
      0x737201dau,
      0x10001dbu,
      0x80000018u,
      0x757401e5u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x737201e8u,
      0x626101e6u,
      0x10001e7u,
      0x80000019u,
      0x666501e9u,
      0x646301eau,
      0x757401ebu,
      0x6a6901ecu,
      0x706f01edu,
      0x6f6e01eeu,
      0x10001efu,
      0x8000001au,
      0x6a6901f1u,
      0x747301f2u,
      0x747301f3u,
      0x6a6901f4u,
      0x777601f5u,
      0x666501f6u,
      0x10001f7u,
      0x8000001bu,
      0x736c0207u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c0219u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7776021eu,
      0x6d6c020eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x1000218u,
      0x706f020fu,
      0x67660210u,
      0x67660211u,
      0x42410212u,
      0x6f6e0213u,
      0x68670214u,
      0x6d6c0215u,
      0x66650216u,
      0x1000217u,
      0x8000001cu,
      0x8000001du,
      0x7574021au,
      0x6665021bu,
      0x7372021cu,
      0x100021du,
      0x8000001eu,
      0x7a79021fu,
      0x1000220u,
      0x8000001fu,
      0x706f0222u,
      0x6e6d0223u,
      0x66650224u,
      0x75740225u,
      0x73720226u,
      0x7a790227u,
      0x1000228u,
      0x80000020u,
      0x6a69022au,
      0x6867022bu,
      0x6968022cu,
      0x7574022du,
      0x100022eu,
      0x80000021u,
      0x62610235u,
      0x77410291u,
      0x737202feu,
      0x0u,
      0x0u,
      0x73690300u,
      0x68670236u,
      0x66650237u,
      0x53000238u,
      0x80000022u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6665028bu,
      0x6867028cu,
      0x6a69028du,
      0x706f028eu,
      0x6f6e028fu,
      0x1000290u,
      0x80000023u,
      0x757402c7u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x676602d0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x737202d6u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x757402dfu,
      0x666502e5u,
      0x0u,
      0x626102ecu,
      0x757402c8u,
      0x737202c9u,
      0x6a6902cau,
      0x636202cbu,
      0x767502ccu,
      0x757402cdu,
      0x666502ceu,
      0x10002cfu,
      0x80000024u,
      0x676602d1u,
      0x747302d2u,
      0x666502d3u,
      0x757402d4u,
      0x10002d5u,
      0x80000025u,
      0x626102d7u,
      0x6f6e02d8u,
      0x747302d9u,
      0x676602dau,
      0x706f02dbu,
      0x737202dcu,
      0x6e6d02ddu,
      0x10002deu,
      0x80000026u,
      0x626102e0u,
      0x6f6e02e1u,
      0x646302e2u,
      0x666502e3u,
      0x10002e4u,
      0x80000027u,
      0x6f6e02e6u,
      0x747302e7u,
      0x6a6902e8u,
      0x757402e9u,
      0x7a7902eau,
      0x10002ebu,
      0x80000028u,
      0x6d6c02edu,
      0x6a6902eeu,
      0x656402efu,
      0x4e4d02f0u,
      0x626102f1u,
      0x757402f2u,
      0x666502f3u,
      0x737202f4u,
      0x6a6902f5u,
      0x626102f6u,
      0x6d6c02f7u,
      0x444302f8u,
      0x706f02f9u,
      0x6d6c02fau,
      0x706f02fbu,
      0x737202fcu,
      0x10002fdu,
      0x80000029u,
      0x10002ffu,
      0x8000002au,
      0x6564030au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610373u,
      0x6665030bu,
      0x7473030cu,
      0x6463030du,
      0x6665030eu,
      0x6f6e030fu,
      0x64630310u,
      0x66650311u,
      0x55000312u,
      0x8000002bu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f0367u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6968036au,
      0x73720368u,
      0x1000369u,
      0x8000002cu,
      0x6a69036bu,
      0x6463036cu,
      0x6c6b036du,
      0x6f6e036eu,
      0x6665036fu,
      0x74730370u,
      0x74730371u,
      0x1000372u,
      0x8000002du,
      0x65640374u,
      0x6a690375u,
      0x62610376u,
      0x6f6e0377u,
      0x64630378u,
      0x66650379u,
      0x100037au,
      0x8000002eu,
      0x6867037cu,
      0x6968037du,
      0x7574037eu,
      0x5400037fu,
      0x8000002fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626103d3u,
      0x6e6d03d4u,
      0x717003d5u,
      0x6d6c03d6u,
      0x666503d7u,
      0x747303d8u,
      0x10003d9u,
      0x80000030u,
      0x797403e3u,
      0x0u,
      0x0u,
      0x0u,
      0x75740425u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0436u,
      0x666503e8u,
      0x0u,
      0x0u,
      0x0u,
      0x544303eeu,
      0x737203e9u,
      0x6a6903eau,
      0x626103ebu,
      0x6d6c03ecu,
      0x10003edu,
      0x80000031u,
      0x706f03ffu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6261040bu,
      0x0u,
      0x0u,
      0x64630415u,
      0x6f6e0400u,
      0x75740401u,
      0x73720402u,
      0x6a690403u,
      0x63620404u,
      0x76750405u,
      0x75740406u,
      0x6a690407u,
      0x706f0408u,
      0x6f6e0409u,
      0x100040au,
      0x80000032u,
      0x7574040cu,
      0x6968040du,
      0x4d4c040eu,
      0x6665040fu,
      0x6f6e0410u,
      0x68670411u,
      0x75740412u,
      0x69680413u,
      0x1000414u,
      0x80000033u,
      0x62610416u,
      0x75740417u,
      0x75740418u,
      0x66650419u,
      0x7372041au,
      0x6a69041bu,
      0x6f6e041cu,
      0x6867041du,
      0x4645041eu,
      0x7776041fu,
      0x66650420u,
      0x6f6e0421u,
      0x75740422u,
      0x74730423u,
      0x1000424u,
      0x80000034u,
      0x69610426u,
      0x6d6c042eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f0433u,
      0x6d6c042fu,
      0x6a690430u,
      0x64630431u,
      0x1000432u,
      0x80000035u,
      0x65640434u,
      0x1000435u,
      0x80000036u,
      0x44430437u,
      0x706f0438u,
      0x6f6e0439u,
      0x7574043au,
      0x7372043bu,
      0x6a69043cu,
      0x6362043du,
      0x7675043eu,
      0x7574043fu,
      0x6a690440u,
      0x706f0441u,
      0x6f6e0442u,
      0x1000443u,
      0x80000037u,
      0x6e6d0453u,
      0x0u,
      0x0u,
      0x0u,
      0x62610456u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720459u,
      0x66650454u,
      0x1000455u,
      0x80000038u,
      0x73720457u,
      0x1000458u,
      0x80000039u,
      0x6e6d045au,
      0x6261045bu,
      0x6d6c045cu,
      0x100045du,
      0x8000003au,
      0x64630471u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66610479u,
      0x0u,
      0x6a69048du,
      0x0u,
      0x0u,
      0x75740492u,
      0x6d6c0472u,
      0x76750473u,
      0x74730474u,
      0x6a690475u,
      0x706f0476u,
      0x6f6e0477u,
      0x1000478u,
      0x8000003bu,
      0x6463047eu,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0483u,
      0x6a69047fu,
      0x75740480u,
      0x7a790481u,
      0x1000482u,
      0x8000003cu,
      0x6a690484u,
      0x6f6e0485u,
      0x68670486u,
      0x42410487u,
      0x6f6e0488u,
      0x68670489u,
      0x6d6c048au,
      0x6665048bu,
      0x100048cu,
      0x8000003du,
      0x6867048eu,
      0x6a69048fu,
      0x6f6e0490u,
      0x1000491u,
      0x8000003eu,
      0x554f0493u,
      0x67660499u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7372049fu,
      0x6766049au,
      0x7473049bu,
      0x6665049cu,
      0x7574049du,
      0x100049eu,
      0x8000003fu,
      0x626104a0u,
      0x6f6e04a1u,
      0x747304a2u,
      0x676604a3u,
      0x706f04a4u,
      0x737204a5u,
      0x6e6d04a6u,
      0x10004a7u,
      0x80000040u,
      0x797804b2u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x787304bdu,
      0x0u,
      0x0u,
      0x6a6904cbu,
      0x666504b3u,
      0x6d6c04b4u,
      0x545304b5u,
      0x626104b6u,
      0x6e6d04b7u,
      0x717004b8u,
      0x6d6c04b9u,
      0x666504bau,
      0x747304bbu,
      0x10004bcu,
      0x80000041u,
      0x6a6904c2u,
      0x0u,
      0x0u,
      0x0u,
      0x666504c8u,
      0x757404c3u,
      0x6a6904c4u,
      0x706f04c5u,
      0x6f6e04c6u,
      0x10004c7u,
      0x80000042u,
      0x737204c9u,
      0x10004cau,
      0x80000043u,
      0x6e6d04ccu,
      0x6a6904cdu,
      0x757404ceu,
      0x6a6904cfu,
      0x777604d0u,
      0x666504d1u,
      0x2f2e04d2u,
      0x736104d3u,
      0x757404e5u,
      0x0u,
      0x706f04f5u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6404fau,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6261050au,
      0x757404e6u,
      0x737204e7u,
      0x6a6904e8u,
      0x636204e9u,
      0x767504eau,
      0x757404ebu,
      0x666504ecu,
      0x343004edu,
      0x10004f1u,
      0x10004f2u,
      0x10004f3u,
      0x10004f4u,
      0x80000044u,
      0x80000045u,
      0x80000046u,
      0x80000047u,
      0x6d6c04f6u,
      0x706f04f7u,
      0x737204f8u,
      0x10004f9u,
      0x80000048u,
      0x1000505u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x65640506u,
      0x80000049u,
      0x66650507u,
      0x79780508u,
      0x1000509u,
      0x8000004au,
      0x6564050bu,
      0x6a69050cu,
      0x7675050du,
      0x7473050eu,
      0x100050fu,
      0x8000004bu,
      0x6564051fu,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0524u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7675052bu,
      0x6a690520u,
      0x76750521u,
      0x74730522u,
      0x1000523u,
      0x8000004cu,
      0x65640525u,
      0x66650526u,
      0x73720527u,
      0x66650528u,
      0x73720529u,
      0x100052au,
      0x8000004du,
      0x6d67052cu,
      0x69680532u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66650538u,
      0x6f6e0533u,
      0x66650534u,
      0x74730535u,
      0x74730536u,
      0x1000537u,
      0x8000004eu,
      0x75740539u,
      0x7574053au,
      0x6665053bu,
      0x5150053cu,
      0x6261053du,
      0x7574053eu,
      0x6968053fu,
      0x4d4c0540u,
      0x66650541u,
      0x6f6e0542u,
      0x68670543u,
      0x75740544u,
      0x69680545u,
      0x1000546u,
      0x8000004fu,
      0x66610555u,
      0x7b7a057fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66610582u,
      0x0u,
      0x0u,
      0x0u,
      0x626105dau,
      0x73720644u,
      0x6564055au,
      0x0u,
      0x0u,
      0x0u,
      0x6665055fu,
      0x706f055bu,
      0x7877055cu,
      0x7473055du,
      0x100055eu,
      0x80000050u,
      0x6f6e0560u,
      0x53430561u,
      0x706f0571u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f0576u,
      0x6d6c0572u,
      0x706f0573u,
      0x73720574u,
      0x1000575u,
      0x80000051u,
      0x76750577u,
      0x68670578u,
      0x69680579u,
      0x6f6e057au,
      0x6665057bu,
      0x7473057cu,
      0x7473057du,
      0x100057eu,
      0x80000052u,
      0x66650580u,
      0x1000581u,
      0x80000053u,
      0x64630587u,
      0x0u,
      0x0u,
      0x0u,
      0x6463058cu,
      0x6a690588u,
      0x6f6e0589u,
      0x6867058au,
      0x100058bu,
      0x80000054u,
      0x7675058du,
      0x6d6c058eu,
      0x6261058fu,
      0x73720590u,
      0x44000591u,
      0x80000055u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f05d5u,
      0x6d6c05d6u,
      0x706f05d7u,
      0x737205d8u,
      0x10005d9u,
      0x80000056u,
      0x757405dbu,
      0x767505dcu,
      0x747305ddu,
      0x444305deu,
      0x626105dfu,
      0x6d6c05e0u,
      0x6d6c05e1u,
      0x636205e2u,
      0x626105e3u,
      0x646305e4u,
      0x6c6b05e5u,
      0x560005e6u,
      0x80000057u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7473063cu,
      0x6665063du,
      0x7372063eu,
      0x4544063fu,
      0x62610640u,
      0x75740641u,
      0x62610642u,
      0x1000643u,
      0x80000058u,
      0x67660645u,
      0x62610646u,
      0x64630647u,
      0x66650648u,
      0x1000649u,
      0x80000059u,
      0x6a690655u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6261065du,
      0x64630656u,
      0x6c6b0657u,
      0x6f6e0658u,
      0x66650659u,
      0x7473065au,
      0x7473065bu,
      0x100065cu,
      0x8000005au,
      0x6f6e065eu,
      0x7473065fu,
      0x6e6d0660u,
      0x6a690661u,
      0x74730662u,
      0x74730663u,
      0x6a690664u,
      0x706f0665u,
      0x6f6e0666u,
      0x1000667u,
      0x8000005bu,
      0x6a69066bu,
      0x0u,
      0x1000676u,
      0x7574066cu,
      0x4544066du,
      0x6a69066eu,
      0x7473066fu,
      0x75740670u,
      0x62610671u,
      0x6f6e0672u,
      0x64630673u,
      0x66650674u,
      0x1000675u,
      0x8000005cu,
      0x8000005du,
      0x736c0686u,
      0x0u,
      0x0u,
      0x0u,
      0x737206f6u,
      0x0u,
      0x0u,
      0x0u,
      0x7473074fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c075bu,
      0x7675068du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a6906e7u,
      0x6665068eu,
      0x5300068fu,
      0x8000005eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626106e2u,
      0x6f6e06e3u,
      0x686706e4u,
      0x666506e5u,
      0x10006e6u,
      0x8000005fu,
      0x626106e8u,
      0x6f6e06e9u,
      0x646306eau,
      0x666506ebu,
      0x555406ecu,
      0x696806edu,
      0x737206eeu,
      0x666506efu,
      0x747306f0u,
      0x696806f1u,
      0x706f06f2u,
      0x6d6c06f3u,
      0x656406f4u,
      0x10006f5u,
      0x80000060u,
      0x757406f7u,
      0x666506f8u,
      0x797806f9u,
      0x2f2e06fau,
      0x756106fbu,
      0x7574070fu,
      0x0u,
      0x7061071fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f0734u,
      0x0u,
      0x706f073au,
      0x0u,
      0x62610742u,
      0x0u,
      0x62610748u,
      0x75740710u,
      0x73720711u,
      0x6a690712u,
      0x63620713u,
      0x76750714u,
      0x75740715u,
      0x66650716u,
      0x34300717u,
      0x100071bu,
      0x100071cu,
      0x100071du,
      0x100071eu,
      0x80000061u,
      0x80000062u,
      0x80000063u,
      0x80000064u,
      0x7170072eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c0730u,
      0x100072fu,
      0x80000065u,
      0x706f0731u,
      0x73720732u,
      0x1000733u,
      0x80000066u,
      0x73720735u,
      0x6e6d0736u,
      0x62610737u,
      0x6d6c0738u,
      0x1000739u,
      0x80000067u,
      0x7473073bu,
      0x6a69073cu,
      0x7574073du,
      0x6a69073eu,
      0x706f073fu,
      0x6f6e0740u,
      0x1000741u,
      0x80000068u,
      0x65640743u,
      0x6a690744u,
      0x76750745u,
      0x74730746u,
      0x1000747u,
      0x80000069u,
      0x6f6e0749u,
      0x6867074au,
      0x6665074bu,
      0x6f6e074cu,
      0x7574074du,
      0x100074eu,
      0x8000006au,
      0x6a690750u,
      0x63620751u,
      0x6d6c0752u,
      0x66650753u,
      0x4d4c0754u,
      0x6a690755u,
      0x68670756u,
      0x69680757u,
      0x75740758u,
      0x74730759u,
      0x100075au,
      0x8000006bu,
      0x7675075cu,
      0x6e6d075du,
      0x6665075eu,
      0x5400075fu,
      0x8000006cu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626107b3u,
      0x6e6d07b4u,
      0x717007b5u,
      0x6d6c07b6u,
      0x6a6907b7u,
      0x6f6e07b8u,
      0x686707b9u,
      0x535207bau,
      0x626107bbu,
      0x757407bcu,
      0x666507bdu,
      0x10007beu,
      0x8000006du,
      0x737207c3u,
      0x0u,
      0x0u,
      0x626107c7u,
      0x6d6c07c4u,
      0x656407c5u,
      0x10007c6u,
      0x8000006eu,
      0x717007c8u,
      0x4e4d07c9u,
      0x706f07cau,
      0x656407cbu,
      0x666507ccu,
      0x333107cdu,
      0x10007cfu,
      0x10007d0u,
      0x8000006fu,
      0x80000070u};
  uint32_t cur = 0x78610000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static int info_hash(const char *str)
{
  static const uint32_t table[] = {0x69680014u,
      0x6665001bu,
      0x796c0038u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a610057u,
      0x0u,
      0x0u,
      0x6261006cu,
      0x0u,
      0x66650075u,
      0x706f007du,
      0x0u,
      0x7473008cu,
      0x6261008fu,
      0x62610015u,
      0x6f6e0016u,
      0x6f6e0017u,
      0x66650018u,
      0x6d6c0019u,
      0x100001au,
      0x8000000au,
      0x7466001cu,
      0x6261002au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6463002fu,
      0x7675002bu,
      0x6d6c002cu,
      0x7574002du,
      0x100002eu,
      0x80000001u,
      0x73720030u,
      0x6a690031u,
      0x71700032u,
      0x75740033u,
      0x6a690034u,
      0x706f0035u,
      0x6f6e0036u,
      0x1000037u,
      0x80000004u,
      0x66650045u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7574004fu,
      0x6e6d0046u,
      0x66650047u,
      0x6f6e0048u,
      0x75740049u,
      0x5554004au,
      0x7a79004bu,
      0x7170004cu,
      0x6665004du,
      0x100004eu,
      0x80000005u,
      0x66650050u,
      0x6f6e0051u,
      0x74730052u,
      0x6a690053u,
      0x706f0054u,
      0x6f6e0055u,
      0x1000056u,
      0x80000008u,
      0x79780060u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0066u,
      0x6a690061u,
      0x6e6d0062u,
      0x76750063u,
      0x6e6d0064u,
      0x1000065u,
      0x80000003u,
      0x6a690067u,
      0x6e6d0068u,
      0x76750069u,
      0x6e6d006au,
      0x100006bu,
      0x80000002u,
      0x7372006du,
      0x6261006eu,
      0x6e6d006fu,
      0x66650070u,
      0x75740071u,
      0x66650072u,
      0x73720073u,
      0x1000074u,
      0x80000009u,
      0x72710076u,
      0x76750077u,
      0x6a690078u,
      0x73720079u,
      0x6665007au,
      0x6564007bu,
      0x100007cu,
      0x80000000u,
      0x7675007eu,
      0x7372007fu,
      0x64630080u,
      0x66650081u,
      0x46450082u,
      0x79780083u,
      0x75740084u,
      0x66650085u,
      0x6f6e0086u,
      0x74730087u,
      0x6a690088u,
      0x706f0089u,
      0x6f6e008au,
      0x100008bu,
      0x80000007u,
      0x6665008du,
      0x100008eu,
      0x8000000bu,
      0x6d6c0090u,
      0x76750091u,
      0x66650092u,
      0x1000093u,
      0x80000006u};
  uint32_t cur = 0x77630000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static const int32_t anari_true = 1;
static const int32_t anari_false = 0;
const char **query_extensions()
{
  static const char *extensions[] = {"ANARI_OSPRAY_RENDERER_DEFAULT",
      "ANARI_OSPRAY_RENDERER_PATHTRACER",
      "ANARI_OSPRAY_RENDERER_SCIVIS",
      "ANARI_OSPRAY_RENDERER_DEBUG",
      "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
      "ANARI_KHR_CAMERA_PERSPECTIVE",
      "ANARI_KHR_GEOMETRY_CONE",
      "ANARI_KHR_GEOMETRY_CURVE",
      "ANARI_KHR_GEOMETRY_CYLINDER",
      "ANARI_KHR_GEOMETRY_QUAD",
      "ANARI_KHR_GEOMETRY_SPHERE",
      "ANARI_KHR_GEOMETRY_TRIANGLE",
      "ANARI_KHR_LIGHT_DIRECTIONAL",
      "ANARI_KHR_LIGHT_POINT",
      "ANARI_KHR_LIGHT_SPOT",
      "ANARI_KHR_MATERIAL_MATTE",
      "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
      "ANARI_KHR_SAMPLER_IMAGE1D",
      "ANARI_KHR_SAMPLER_IMAGE2D",
      "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
      "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
      "ANARI_OSPRAY_EXTENSIONS",
      0};
  return extensions;
}
const char **query_object_types(ANARIDataType type)
{
  switch (type) {
  case ANARI_RENDERER: {
    static const char *ANARI_RENDERER_subtypes[] = {
        "default", "pathtracer", "scivis", "debug", 0};
    return ANARI_RENDERER_subtypes;
  }
  case ANARI_CAMERA: {
    static const char *ANARI_CAMERA_subtypes[] = {
        "orthographic", "perspective", 0};
    return ANARI_CAMERA_subtypes;
  }
  case ANARI_GEOMETRY: {
    static const char *ANARI_GEOMETRY_subtypes[] = {
        "cone", "curve", "cylinder", "quad", "sphere", "triangle", 0};
    return ANARI_GEOMETRY_subtypes;
  }
  case ANARI_LIGHT: {
    static const char *ANARI_LIGHT_subtypes[] = {
        "directional", "point", "spot", 0};
    return ANARI_LIGHT_subtypes;
  }
  case ANARI_MATERIAL: {
    static const char *ANARI_MATERIAL_subtypes[] = {
        "matte", "physicallyBased", 0};
    return ANARI_MATERIAL_subtypes;
  }
  case ANARI_SAMPLER: {
    static const char *ANARI_SAMPLER_subtypes[] = {"image1D", "image2D", 0};
    return ANARI_SAMPLER_subtypes;
  }
  case ANARI_SPATIAL_FIELD: {
    static const char *ANARI_SPATIAL_FIELD_subtypes[] = {
        "structuredRegular", 0};
    return ANARI_SPATIAL_FIELD_subtypes;
  }
  case ANARI_VOLUME: {
    static const char *ANARI_VOLUME_subtypes[] = {"transferFunction1D", 0};
    return ANARI_VOLUME_subtypes;
  }
  default: {
    static const char *none_subtypes[] = {0};
    return none_subtypes;
  }
  }
}
static const void *ANARI_DEVICE_allowInvalidMaterials_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "show surfaces with invalid materials";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_invalidMaterialColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          1.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "color to identify surfaces with invalid materials";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_statusCallback_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "callback used to report information to the application";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_statusCallbackUserData_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "optional pointer passed as the first argument of the status callback";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 0:
    return ANARI_DEVICE_allowInvalidMaterials_info(
        paramType, infoName, infoType);
  case 41:
    return ANARI_DEVICE_invalidMaterialColor_info(
        paramType, infoName, infoType);
  case 56:
    return ANARI_DEVICE_name_info(paramType, infoName, infoType);
  case 87:
    return ANARI_DEVICE_statusCallback_info(paramType, infoName, infoType);
  case 88:
    return ANARI_DEVICE_statusCallbackUserData_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_lightSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(-1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of random light samples per path vertex, per default all light sources are sampled";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_roulettePathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(5)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "ray recursion depth at which to start Russian roulette termination";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxScatteringEvents_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum number of non-specular (i.e., diffuse and glossy) bounces";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "samples are clamped to this value before they are accumulated into the framebuffer";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_backgroundRefraction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "allow for alpha blending even if background is seen through refractive objects like glass";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_RENDERER_default_pixelSamples_info(
        paramType, infoName, infoType);
  case 51:
    return ANARI_RENDERER_default_maxPathLength_info(
        paramType, infoName, infoType);
  case 55:
    return ANARI_RENDERER_default_minContribution_info(
        paramType, infoName, infoType);
  case 96:
    return ANARI_RENDERER_default_varianceThreshold_info(
        paramType, infoName, infoType);
  case 14:
    return ANARI_RENDERER_default_background_info(
        paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_default_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_default_ambientRadiance_info(
        paramType, infoName, infoType);
  case 48:
    return ANARI_RENDERER_default_lightSamples_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_RENDERER_default_roulettePathLength_info(
        paramType, infoName, infoType);
  case 52:
    return ANARI_RENDERER_default_maxScatteringEvents_info(
        paramType, infoName, infoType);
  case 50:
    return ANARI_RENDERER_default_maxContribution_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_default_backgroundRefraction_info(
        paramType, infoName, infoType);
  case 56:
    return ANARI_RENDERER_default_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_lightSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(-1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of random light samples per path vertex, per default all light sources are sampled";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_roulettePathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(5)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "ray recursion depth at which to start Russian roulette termination";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxScatteringEvents_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum number of non-specular (i.e., diffuse and glossy) bounces";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "samples are clamped to this value before they are accumulated into the framebuffer";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_backgroundRefraction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "allow for alpha blending even if background is seen through refractive objects like glass";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_RENDERER_pathtracer_pixelSamples_info(
        paramType, infoName, infoType);
  case 51:
    return ANARI_RENDERER_pathtracer_maxPathLength_info(
        paramType, infoName, infoType);
  case 55:
    return ANARI_RENDERER_pathtracer_minContribution_info(
        paramType, infoName, infoType);
  case 96:
    return ANARI_RENDERER_pathtracer_varianceThreshold_info(
        paramType, infoName, infoType);
  case 14:
    return ANARI_RENDERER_pathtracer_background_info(
        paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_pathtracer_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_pathtracer_ambientRadiance_info(
        paramType, infoName, infoType);
  case 48:
    return ANARI_RENDERER_pathtracer_lightSamples_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_RENDERER_pathtracer_roulettePathLength_info(
        paramType, infoName, infoType);
  case 52:
    return ANARI_RENDERER_pathtracer_maxScatteringEvents_info(
        paramType, infoName, infoType);
  case 50:
    return ANARI_RENDERER_pathtracer_maxContribution_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_pathtracer_backgroundRefraction_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_shadows_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "whether to compute (hard) shadows";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_aoSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of rays per sample to compute ambient occlusion";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_aoDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum distance to consider for ambient occlusion";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_volumeSamplingRate_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sampling rate for volumes";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_visibleLights_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "whether light sources are potentially visible (as in the path tracer, regarding each light's visible)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_RENDERER_scivis_pixelSamples_info(
        paramType, infoName, infoType);
  case 51:
    return ANARI_RENDERER_scivis_maxPathLength_info(
        paramType, infoName, infoType);
  case 55:
    return ANARI_RENDERER_scivis_minContribution_info(
        paramType, infoName, infoType);
  case 96:
    return ANARI_RENDERER_scivis_varianceThreshold_info(
        paramType, infoName, infoType);
  case 14:
    return ANARI_RENDERER_scivis_background_info(paramType, infoName, infoType);
  case 80:
    return ANARI_RENDERER_scivis_shadows_info(paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_scivis_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_scivis_ambientRadiance_info(
        paramType, infoName, infoType);
  case 6:
    return ANARI_RENDERER_scivis_aoSamples_info(paramType, infoName, infoType);
  case 5:
    return ANARI_RENDERER_scivis_aoDistance_info(paramType, infoName, infoType);
  case 109:
    return ANARI_RENDERER_scivis_volumeSamplingRate_info(
        paramType, infoName, infoType);
  case 107:
    return ANARI_RENDERER_scivis_visibleLights_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_method_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "which debugging method to use";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"eyeLight",
          "rayDir",
          "Ng",
          "Ns",
          "color",
          "texCoord",
          "backfacing_Ng",
          "backfacing_Ns",
          "dPds",
          "dPdt",
          "primID",
          "geomID",
          "instID",
          "volume",
          "rayDir",
          "testFrame",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 54:
    return ANARI_RENDERER_debug_method_info(paramType, infoName, infoType);
  case 65:
    return ANARI_RENDERER_debug_pixelSamples_info(
        paramType, infoName, infoType);
  case 51:
    return ANARI_RENDERER_debug_maxPathLength_info(
        paramType, infoName, infoType);
  case 55:
    return ANARI_RENDERER_debug_minContribution_info(
        paramType, infoName, infoType);
  case 96:
    return ANARI_RENDERER_debug_varianceThreshold_info(
        paramType, infoName, infoType);
  case 14:
    return ANARI_RENDERER_debug_background_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_ARRAY1D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_ARRAY2D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_ARRAY3D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_world_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "world to be rendererd";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_renderer_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "renderer which renders the frame";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_camera_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera used to render the world";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_size_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "size of the frame in pixels (width, height)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_channel_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "enables mapping the color channel as the type specified";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_channel_depth_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "enables mapping the color channel as the type specified";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_FRAME_name_info(paramType, infoName, infoType);
  case 110:
    return ANARI_FRAME_world_info(paramType, infoName, infoType);
  case 77:
    return ANARI_FRAME_renderer_info(paramType, infoName, infoType);
  case 17:
    return ANARI_FRAME_camera_info(paramType, infoName, infoType);
  case 83:
    return ANARI_FRAME_size_info(paramType, infoName, infoType);
  case 19:
    return ANARI_FRAME_channel_color_info(paramType, infoName, infoType);
  case 20:
    return ANARI_FRAME_channel_depth_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_surface_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of surface objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_volume_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of volume objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_VOLUME, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_light_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of light objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_GROUP_name_info(paramType, infoName, infoType);
  case 89:
    return ANARI_GROUP_surface_info(paramType, infoName, infoType);
  case 108:
    return ANARI_GROUP_volume_info(paramType, infoName, infoType);
  case 47:
    return ANARI_GROUP_light_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_instance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of instance objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_INSTANCE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_surface_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced surface objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_volume_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced volume objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_light_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced light objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_WORLD_name_info(paramType, infoName, infoType);
  case 39:
    return ANARI_WORLD_instance_info(paramType, infoName, infoType);
  case 89:
    return ANARI_WORLD_surface_info(paramType, infoName, infoType);
  case 108:
    return ANARI_WORLD_volume_info(paramType, infoName, infoType);
  case 47:
    return ANARI_WORLD_light_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_geometry_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "geometry object defining the surface geometry";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_material_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "material object defining the surface appearance";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_SURFACE_name_info(paramType, infoName, infoType);
  case 32:
    return ANARI_SURFACE_geometry_info(paramType, infoName, infoType);
  case 49:
    return ANARI_SURFACE_material_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera position";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "main viewing direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_up_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera up direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_imageRegion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "region mapped to the frame";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_aspect_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "aspect ratio";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_height_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "height of image plane";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_near_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "near plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_far_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "far plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_CAMERA_orthographic_name_info(paramType, infoName, infoType);
  case 66:
    return ANARI_CAMERA_orthographic_position_info(
        paramType, infoName, infoType);
  case 26:
    return ANARI_CAMERA_orthographic_direction_info(
        paramType, infoName, infoType);
  case 93:
    return ANARI_CAMERA_orthographic_up_info(paramType, infoName, infoType);
  case 35:
    return ANARI_CAMERA_orthographic_imageRegion_info(
        paramType, infoName, infoType);
  case 7:
    return ANARI_CAMERA_orthographic_aspect_info(paramType, infoName, infoType);
  case 33:
    return ANARI_CAMERA_orthographic_height_info(paramType, infoName, infoType);
  case 57:
    return ANARI_CAMERA_orthographic_near_info(paramType, infoName, infoType);
  case 29:
    return ANARI_CAMERA_orthographic_far_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera position";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "main viewing direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_up_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera up direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_imageRegion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "region mapped to the frame";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_fovy_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.047198f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertical field of view in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_aspect_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "aspect ratio";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_near_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "near plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_far_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "far plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_CAMERA_perspective_name_info(paramType, infoName, infoType);
  case 66:
    return ANARI_CAMERA_perspective_position_info(
        paramType, infoName, infoType);
  case 26:
    return ANARI_CAMERA_perspective_direction_info(
        paramType, infoName, infoType);
  case 93:
    return ANARI_CAMERA_perspective_up_info(paramType, infoName, infoType);
  case 35:
    return ANARI_CAMERA_perspective_imageRegion_info(
        paramType, infoName, infoType);
  case 31:
    return ANARI_CAMERA_perspective_fovy_info(paramType, infoName, infoType);
  case 7:
    return ANARI_CAMERA_perspective_aspect_info(paramType, infoName, infoType);
  case 57:
    return ANARI_CAMERA_perspective_near_info(paramType, infoName, infoType);
  case 29:
    return ANARI_CAMERA_perspective_far_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_cap_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex cap type";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_caps_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "none";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cap type";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "none", "first", "second", "both", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_GEOMETRY_cone_name_info(paramType, infoName, infoType);
  case 24:
    return ANARI_GEOMETRY_cone_color_info(paramType, infoName, infoType);
  case 10:
    return ANARI_GEOMETRY_cone_attribute0_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_cone_attribute1_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_cone_attribute2_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_cone_attribute3_info(paramType, infoName, infoType);
  case 72:
    return ANARI_GEOMETRY_cone_primitive_color_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_GEOMETRY_cone_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 69:
    return ANARI_GEOMETRY_cone_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 70:
    return ANARI_GEOMETRY_cone_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 71:
    return ANARI_GEOMETRY_cone_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 73:
    return ANARI_GEOMETRY_cone_primitive_id_info(paramType, infoName, infoType);
  case 104:
    return ANARI_GEOMETRY_cone_vertex_position_info(
        paramType, infoName, infoType);
  case 105:
    return ANARI_GEOMETRY_cone_vertex_radius_info(
        paramType, infoName, infoType);
  case 101:
    return ANARI_GEOMETRY_cone_vertex_cap_info(paramType, infoName, infoType);
  case 102:
    return ANARI_GEOMETRY_cone_vertex_color_info(paramType, infoName, infoType);
  case 97:
    return ANARI_GEOMETRY_cone_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 98:
    return ANARI_GEOMETRY_cone_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 99:
    return ANARI_GEOMETRY_cone_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 100:
    return ANARI_GEOMETRY_cone_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 74:
    return ANARI_GEOMETRY_cone_primitive_index_info(
        paramType, infoName, infoType);
  case 18:
    return ANARI_GEOMETRY_cone_caps_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global radius";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_GEOMETRY_curve_name_info(paramType, infoName, infoType);
  case 24:
    return ANARI_GEOMETRY_curve_color_info(paramType, infoName, infoType);
  case 10:
    return ANARI_GEOMETRY_curve_attribute0_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_curve_attribute1_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_curve_attribute2_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_curve_attribute3_info(paramType, infoName, infoType);
  case 72:
    return ANARI_GEOMETRY_curve_primitive_color_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_GEOMETRY_curve_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 69:
    return ANARI_GEOMETRY_curve_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 70:
    return ANARI_GEOMETRY_curve_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 71:
    return ANARI_GEOMETRY_curve_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 73:
    return ANARI_GEOMETRY_curve_primitive_id_info(
        paramType, infoName, infoType);
  case 104:
    return ANARI_GEOMETRY_curve_vertex_position_info(
        paramType, infoName, infoType);
  case 105:
    return ANARI_GEOMETRY_curve_vertex_radius_info(
        paramType, infoName, infoType);
  case 102:
    return ANARI_GEOMETRY_curve_vertex_color_info(
        paramType, infoName, infoType);
  case 97:
    return ANARI_GEOMETRY_curve_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 98:
    return ANARI_GEOMETRY_curve_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 99:
    return ANARI_GEOMETRY_curve_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 100:
    return ANARI_GEOMETRY_curve_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 74:
    return ANARI_GEOMETRY_curve_primitive_index_info(
        paramType, infoName, infoType);
  case 76:
    return ANARI_GEOMETRY_curve_radius_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_cap_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cylinder cap type";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cylinder radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cylinder radius";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_caps_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "none";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cylinder cap type";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "none", "first", "second", "both", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_GEOMETRY_cylinder_name_info(paramType, infoName, infoType);
  case 24:
    return ANARI_GEOMETRY_cylinder_color_info(paramType, infoName, infoType);
  case 10:
    return ANARI_GEOMETRY_cylinder_attribute0_info(
        paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_cylinder_attribute1_info(
        paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_cylinder_attribute2_info(
        paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_cylinder_attribute3_info(
        paramType, infoName, infoType);
  case 72:
    return ANARI_GEOMETRY_cylinder_primitive_color_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_GEOMETRY_cylinder_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 69:
    return ANARI_GEOMETRY_cylinder_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 70:
    return ANARI_GEOMETRY_cylinder_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 71:
    return ANARI_GEOMETRY_cylinder_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 73:
    return ANARI_GEOMETRY_cylinder_primitive_id_info(
        paramType, infoName, infoType);
  case 104:
    return ANARI_GEOMETRY_cylinder_vertex_position_info(
        paramType, infoName, infoType);
  case 101:
    return ANARI_GEOMETRY_cylinder_vertex_cap_info(
        paramType, infoName, infoType);
  case 102:
    return ANARI_GEOMETRY_cylinder_vertex_color_info(
        paramType, infoName, infoType);
  case 97:
    return ANARI_GEOMETRY_cylinder_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 98:
    return ANARI_GEOMETRY_cylinder_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 99:
    return ANARI_GEOMETRY_cylinder_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 100:
    return ANARI_GEOMETRY_cylinder_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 74:
    return ANARI_GEOMETRY_cylinder_primitive_index_info(
        paramType, infoName, infoType);
  case 75:
    return ANARI_GEOMETRY_cylinder_primitive_radius_info(
        paramType, infoName, infoType);
  case 76:
    return ANARI_GEOMETRY_cylinder_radius_info(paramType, infoName, infoType);
  case 18:
    return ANARI_GEOMETRY_cylinder_caps_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_tangent_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3,
          ANARI_FIXED16_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_FIXED16_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC4, ANARI_UINT64_VEC4, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_GEOMETRY_quad_name_info(paramType, infoName, infoType);
  case 24:
    return ANARI_GEOMETRY_quad_color_info(paramType, infoName, infoType);
  case 10:
    return ANARI_GEOMETRY_quad_attribute0_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_quad_attribute1_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_quad_attribute2_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_quad_attribute3_info(paramType, infoName, infoType);
  case 72:
    return ANARI_GEOMETRY_quad_primitive_color_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_GEOMETRY_quad_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 69:
    return ANARI_GEOMETRY_quad_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 70:
    return ANARI_GEOMETRY_quad_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 71:
    return ANARI_GEOMETRY_quad_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 73:
    return ANARI_GEOMETRY_quad_primitive_id_info(paramType, infoName, infoType);
  case 104:
    return ANARI_GEOMETRY_quad_vertex_position_info(
        paramType, infoName, infoType);
  case 103:
    return ANARI_GEOMETRY_quad_vertex_normal_info(
        paramType, infoName, infoType);
  case 106:
    return ANARI_GEOMETRY_quad_vertex_tangent_info(
        paramType, infoName, infoType);
  case 102:
    return ANARI_GEOMETRY_quad_vertex_color_info(paramType, infoName, infoType);
  case 97:
    return ANARI_GEOMETRY_quad_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 98:
    return ANARI_GEOMETRY_quad_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 99:
    return ANARI_GEOMETRY_quad_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 100:
    return ANARI_GEOMETRY_quad_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 74:
    return ANARI_GEOMETRY_quad_primitive_index_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sphere position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sphere radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global sphere radius";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_GEOMETRY_sphere_name_info(paramType, infoName, infoType);
  case 24:
    return ANARI_GEOMETRY_sphere_color_info(paramType, infoName, infoType);
  case 10:
    return ANARI_GEOMETRY_sphere_attribute0_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_sphere_attribute1_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_sphere_attribute2_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_sphere_attribute3_info(paramType, infoName, infoType);
  case 72:
    return ANARI_GEOMETRY_sphere_primitive_color_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_GEOMETRY_sphere_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 69:
    return ANARI_GEOMETRY_sphere_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 70:
    return ANARI_GEOMETRY_sphere_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 71:
    return ANARI_GEOMETRY_sphere_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 73:
    return ANARI_GEOMETRY_sphere_primitive_id_info(
        paramType, infoName, infoType);
  case 104:
    return ANARI_GEOMETRY_sphere_vertex_position_info(
        paramType, infoName, infoType);
  case 105:
    return ANARI_GEOMETRY_sphere_vertex_radius_info(
        paramType, infoName, infoType);
  case 102:
    return ANARI_GEOMETRY_sphere_vertex_color_info(
        paramType, infoName, infoType);
  case 97:
    return ANARI_GEOMETRY_sphere_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 98:
    return ANARI_GEOMETRY_sphere_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 99:
    return ANARI_GEOMETRY_sphere_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 100:
    return ANARI_GEOMETRY_sphere_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 74:
    return ANARI_GEOMETRY_sphere_primitive_index_info(
        paramType, infoName, infoType);
  case 76:
    return ANARI_GEOMETRY_sphere_radius_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_tangent_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3,
          ANARI_FIXED16_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_FIXED16_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC3, ANARI_UINT64_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_GEOMETRY_triangle_name_info(paramType, infoName, infoType);
  case 24:
    return ANARI_GEOMETRY_triangle_color_info(paramType, infoName, infoType);
  case 10:
    return ANARI_GEOMETRY_triangle_attribute0_info(
        paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_triangle_attribute1_info(
        paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_triangle_attribute2_info(
        paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_triangle_attribute3_info(
        paramType, infoName, infoType);
  case 72:
    return ANARI_GEOMETRY_triangle_primitive_color_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_GEOMETRY_triangle_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 69:
    return ANARI_GEOMETRY_triangle_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 70:
    return ANARI_GEOMETRY_triangle_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 71:
    return ANARI_GEOMETRY_triangle_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 73:
    return ANARI_GEOMETRY_triangle_primitive_id_info(
        paramType, infoName, infoType);
  case 104:
    return ANARI_GEOMETRY_triangle_vertex_position_info(
        paramType, infoName, infoType);
  case 103:
    return ANARI_GEOMETRY_triangle_vertex_normal_info(
        paramType, infoName, infoType);
  case 106:
    return ANARI_GEOMETRY_triangle_vertex_tangent_info(
        paramType, infoName, infoType);
  case 102:
    return ANARI_GEOMETRY_triangle_vertex_color_info(
        paramType, infoName, infoType);
  case 97:
    return ANARI_GEOMETRY_triangle_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 98:
    return ANARI_GEOMETRY_triangle_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 99:
    return ANARI_GEOMETRY_triangle_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 100:
    return ANARI_GEOMETRY_triangle_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 74:
    return ANARI_GEOMETRY_triangle_primitive_index_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_irradiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "amount of light in W/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "emission direction of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_LIGHT_directional_name_info(paramType, infoName, infoType);
  case 24:
    return ANARI_LIGHT_directional_color_info(paramType, infoName, infoType);
  case 46:
    return ANARI_LIGHT_directional_irradiance_info(
        paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_directional_direction_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_LIGHT_point_name_info(paramType, infoName, infoType);
  case 24:
    return ANARI_LIGHT_point_color_info(paramType, infoName, infoType);
  case 66:
    return ANARI_LIGHT_point_position_info(paramType, infoName, infoType);
  case 40:
    return ANARI_LIGHT_point_intensity_info(paramType, infoName, infoType);
  case 67:
    return ANARI_LIGHT_point_power_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "the axis of the spot";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_openingAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {3.141593f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opening angle in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_falloffAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.100000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "falloff angle in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_LIGHT_spot_name_info(paramType, infoName, infoType);
  case 24:
    return ANARI_LIGHT_spot_color_info(paramType, infoName, infoType);
  case 66:
    return ANARI_LIGHT_spot_position_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_spot_direction_info(paramType, infoName, infoType);
  case 61:
    return ANARI_LIGHT_spot_openingAngle_info(paramType, infoName, infoType);
  case 28:
    return ANARI_LIGHT_spot_falloffAngle_info(paramType, infoName, infoType);
  case 40:
    return ANARI_LIGHT_spot_intensity_info(paramType, infoName, infoType);
  case 67:
    return ANARI_LIGHT_spot_power_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.800000f, 0.800000f, 0.800000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "diffuse color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opacity";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_alphaMode_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "opaque";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "alpha mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"opaque", "blend", "mask", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_alphaCutoff_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cutoff for alpha mask mode";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_MATERIAL_matte_name_info(paramType, infoName, infoType);
  case 24:
    return ANARI_MATERIAL_matte_color_info(paramType, infoName, infoType);
  case 60:
    return ANARI_MATERIAL_matte_opacity_info(paramType, infoName, infoType);
  case 2:
    return ANARI_MATERIAL_matte_alphaMode_info(paramType, infoName, infoType);
  case 1:
    return ANARI_MATERIAL_matte_alphaCutoff_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_baseColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "base color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opacity";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_metallic_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "metallic factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_roughness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "roughness factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "normal map";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_emissive_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "emissive factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_occlusion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "precomputed occlusion";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_alphaMode_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "opaque";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "alpha mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"opaque", "blend", "mask", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_alphaCutoff_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cutoff for alpha mask mode";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_specular_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "specular factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_specularColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "specular color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_clearcoat_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "clearcoat factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_clearcoatRoughness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "clearcoat roughness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_clearcoatNormal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "clearcoat normal map";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_transmission_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transmission factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_ior_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index of refraction";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_thickness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wall thickness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_attenuationDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {INFINITY};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "attenuation distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_attenuationColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "attenuation color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_sheenColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sheen color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_sheenRoughness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sheen roughness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_iridescence_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "iridescence factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_iridescenceIor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.300000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "iridescence index of refraction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_iridescenceThickness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "iridescence thicknness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_MATERIAL_physicallyBased_name_info(
        paramType, infoName, infoType);
  case 16:
    return ANARI_MATERIAL_physicallyBased_baseColor_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_MATERIAL_physicallyBased_opacity_info(
        paramType, infoName, infoType);
  case 53:
    return ANARI_MATERIAL_physicallyBased_metallic_info(
        paramType, infoName, infoType);
  case 78:
    return ANARI_MATERIAL_physicallyBased_roughness_info(
        paramType, infoName, infoType);
  case 58:
    return ANARI_MATERIAL_physicallyBased_normal_info(
        paramType, infoName, infoType);
  case 27:
    return ANARI_MATERIAL_physicallyBased_emissive_info(
        paramType, infoName, infoType);
  case 59:
    return ANARI_MATERIAL_physicallyBased_occlusion_info(
        paramType, infoName, infoType);
  case 2:
    return ANARI_MATERIAL_physicallyBased_alphaMode_info(
        paramType, infoName, infoType);
  case 1:
    return ANARI_MATERIAL_physicallyBased_alphaCutoff_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_MATERIAL_physicallyBased_specular_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_MATERIAL_physicallyBased_specularColor_info(
        paramType, infoName, infoType);
  case 21:
    return ANARI_MATERIAL_physicallyBased_clearcoat_info(
        paramType, infoName, infoType);
  case 23:
    return ANARI_MATERIAL_physicallyBased_clearcoatRoughness_info(
        paramType, infoName, infoType);
  case 22:
    return ANARI_MATERIAL_physicallyBased_clearcoatNormal_info(
        paramType, infoName, infoType);
  case 91:
    return ANARI_MATERIAL_physicallyBased_transmission_info(
        paramType, infoName, infoType);
  case 42:
    return ANARI_MATERIAL_physicallyBased_ior_info(
        paramType, infoName, infoType);
  case 90:
    return ANARI_MATERIAL_physicallyBased_thickness_info(
        paramType, infoName, infoType);
  case 9:
    return ANARI_MATERIAL_physicallyBased_attenuationDistance_info(
        paramType, infoName, infoType);
  case 8:
    return ANARI_MATERIAL_physicallyBased_attenuationColor_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_MATERIAL_physicallyBased_sheenColor_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_MATERIAL_physicallyBased_sheenRoughness_info(
        paramType, infoName, infoType);
  case 43:
    return ANARI_MATERIAL_physicallyBased_iridescence_info(
        paramType, infoName, infoType);
  case 44:
    return ANARI_MATERIAL_physicallyBased_iridescenceIor_info(
        paramType, infoName, infoType);
  case 45:
    return ANARI_MATERIAL_physicallyBased_iridescenceThickness_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_image_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array backing the sampler";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inAttribute_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "attribute0";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "input surface attribute (texture coordinate)";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "nearest";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_wrapMode1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 1st dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "transform applied to the input attribute before sampling";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output inTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_outTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transform applied to the sampled values";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_outOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output outTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_SAMPLER_image1D_name_info(paramType, infoName, infoType);
  case 34:
    return ANARI_SAMPLER_image1D_image_info(paramType, infoName, infoType);
  case 36:
    return ANARI_SAMPLER_image1D_inAttribute_info(
        paramType, infoName, infoType);
  case 30:
    return ANARI_SAMPLER_image1D_filter_info(paramType, infoName, infoType);
  case 111:
    return ANARI_SAMPLER_image1D_wrapMode1_info(paramType, infoName, infoType);
  case 38:
    return ANARI_SAMPLER_image1D_inTransform_info(
        paramType, infoName, infoType);
  case 37:
    return ANARI_SAMPLER_image1D_inOffset_info(paramType, infoName, infoType);
  case 64:
    return ANARI_SAMPLER_image1D_outTransform_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_SAMPLER_image1D_outOffset_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_image_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array backing the sampler";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inAttribute_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "attribute0";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "input surface attribute (texture coordinate)";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "nearest";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_wrapMode1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 1st dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_wrapMode2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 2nd dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "transform applied to the input attribute before sampling";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output inTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_outTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transform applied to the sampled values";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_outOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output outTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_SAMPLER_image2D_name_info(paramType, infoName, infoType);
  case 34:
    return ANARI_SAMPLER_image2D_image_info(paramType, infoName, infoType);
  case 36:
    return ANARI_SAMPLER_image2D_inAttribute_info(
        paramType, infoName, infoType);
  case 30:
    return ANARI_SAMPLER_image2D_filter_info(paramType, infoName, infoType);
  case 111:
    return ANARI_SAMPLER_image2D_wrapMode1_info(paramType, infoName, infoType);
  case 112:
    return ANARI_SAMPLER_image2D_wrapMode2_info(paramType, infoName, infoType);
  case 38:
    return ANARI_SAMPLER_image2D_inTransform_info(
        paramType, infoName, infoType);
  case 37:
    return ANARI_SAMPLER_image2D_inOffset_info(paramType, infoName, infoType);
  case 64:
    return ANARI_SAMPLER_image2D_outTransform_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_SAMPLER_image2D_outOffset_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_data_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of vertex centered scalar values";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8,
          ANARI_INT16,
          ANARI_UINT16,
          ANARI_FLOAT32,
          ANARI_FLOAT64,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_origin_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "origin of the grid in object-space";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "size of the grid cells in object-space";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "linear";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode used to interpolate the grid";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_SPATIAL_FIELD_structuredRegular_name_info(
        paramType, infoName, infoType);
  case 25:
    return ANARI_SPATIAL_FIELD_structuredRegular_data_info(
        paramType, infoName, infoType);
  case 62:
    return ANARI_SPATIAL_FIELD_structuredRegular_origin_info(
        paramType, infoName, infoType);
  case 84:
    return ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(
        paramType, infoName, infoType);
  case 30:
    return ANARI_SPATIAL_FIELD_structuredRegular_filter_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_value_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "spatial field used for the field values of the volume";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_valueRange_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
      static const float default_value[2] = {0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sampled values of field are clamped to this range";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sampled color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sampled opacity";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_unitDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "makes volumes uniformly thinner or thicker";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 56:
    return ANARI_VOLUME_transferFunction1D_name_info(
        paramType, infoName, infoType);
  case 94:
    return ANARI_VOLUME_transferFunction1D_value_info(
        paramType, infoName, infoType);
  case 95:
    return ANARI_VOLUME_transferFunction1D_valueRange_info(
        paramType, infoName, infoType);
  case 24:
    return ANARI_VOLUME_transferFunction1D_color_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_VOLUME_transferFunction1D_opacity_info(
        paramType, infoName, infoType);
  case 92:
    return ANARI_VOLUME_transferFunction1D_unitDistance_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 9:
    return ANARI_CAMERA_orthographic_param_info(
        paramName, paramType, infoName, infoType);
  case 11:
    return ANARI_CAMERA_perspective_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 0:
    return ANARI_GEOMETRY_cone_param_info(
        paramName, paramType, infoName, infoType);
  case 1:
    return ANARI_GEOMETRY_curve_param_info(
        paramName, paramType, infoName, infoType);
  case 2:
    return ANARI_GEOMETRY_cylinder_param_info(
        paramName, paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_quad_param_info(
        paramName, paramType, infoName, infoType);
  case 16:
    return ANARI_GEOMETRY_sphere_param_info(
        paramName, paramType, infoName, infoType);
  case 20:
    return ANARI_GEOMETRY_triangle_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 5:
    return ANARI_LIGHT_directional_param_info(
        paramName, paramType, infoName, infoType);
  case 13:
    return ANARI_LIGHT_point_param_info(
        paramName, paramType, infoName, infoType);
  case 17:
    return ANARI_LIGHT_spot_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 8:
    return ANARI_MATERIAL_matte_param_info(
        paramName, paramType, infoName, infoType);
  case 12:
    return ANARI_MATERIAL_physicallyBased_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 4:
    return ANARI_RENDERER_default_param_info(
        paramName, paramType, infoName, infoType);
  case 10:
    return ANARI_RENDERER_pathtracer_param_info(
        paramName, paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_scivis_param_info(
        paramName, paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_debug_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 6:
    return ANARI_SAMPLER_image1D_param_info(
        paramName, paramType, infoName, infoType);
  case 7:
    return ANARI_SAMPLER_image2D_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 18:
    return ANARI_SPATIAL_FIELD_structuredRegular_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 19:
    return ANARI_VOLUME_transferFunction1D_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_param_info_enum(ANARIDataType type,
    const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (type) {
  case ANARI_CAMERA:
    return ANARI_CAMERA_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_GEOMETRY:
    return ANARI_GEOMETRY_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_LIGHT:
    return ANARI_LIGHT_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_MATERIAL:
    return ANARI_MATERIAL_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_RENDERER:
    return ANARI_RENDERER_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_SAMPLER:
    return ANARI_SAMPLER_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_SPATIAL_FIELD:
    return ANARI_SPATIAL_FIELD_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_VOLUME:
    return ANARI_VOLUME_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_DEVICE:
    return ANARI_DEVICE_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY1D:
    return ANARI_ARRAY1D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY2D:
    return ANARI_ARRAY2D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY3D:
    return ANARI_ARRAY3D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_FRAME:
    return ANARI_FRAME_param_info(paramName, paramType, infoName, infoType);
  case ANARI_GROUP:
    return ANARI_GROUP_param_info(paramName, paramType, infoName, infoType);
  case ANARI_WORLD:
    return ANARI_WORLD_param_info(paramName, paramType, infoName, infoType);
  case ANARI_SURFACE:
    return ANARI_SURFACE_param_info(paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_param_info(ANARIDataType type,
    const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    const char *infoNameString,
    ANARIDataType infoType)
{
  int infoName = info_hash(infoNameString);
  return query_param_info_enum(
      type, subtype, paramName, paramType, infoName, infoType);
}
static const void *ANARI_DEVICE_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "device object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"allowInvalidMaterials", ANARI_BOOL},
          {"invalidMaterialColor", ANARI_FLOAT32_VEC4},
          {"name", ANARI_STRING},
          {"statusCallback", ANARI_STATUS_CALLBACK},
          {"statusCallbackUserData", ANARI_VOID_POINTER},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The path tracer supports soft shadows, indirect illumination and realistic materials.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"lightSamples", ANARI_INT32},
          {"roulettePathLength", ANARI_INT32},
          {"maxScatteringEvents", ANARI_INT32},
          {"maxContribution", ANARI_FLOAT32},
          {"backgroundRefraction", ANARI_BOOL},
          {"name", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 0;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The path tracer supports soft shadows, indirect illumination and realistic materials.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"lightSamples", ANARI_INT32},
          {"roulettePathLength", ANARI_INT32},
          {"maxScatteringEvents", ANARI_INT32},
          {"maxContribution", ANARI_FLOAT32},
          {"backgroundRefraction", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 1;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The SciVis renderer is a fast ray tracer for scientific visualization which supports volume rendering and ambient occlusion (AO).";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"shadows", ANARI_BOOL},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"aoSamples", ANARI_INT32},
          {"aoDistance", ANARI_FLOAT32},
          {"volumeSamplingRate", ANARI_FLOAT32},
          {"visibleLights", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 2;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "This renderer is used for debugging the underlying OSPRay system.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"method", ANARI_STRING},
          {"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 3;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "one dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "two dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "three dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "frame object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"world", ANARI_WORLD},
          {"renderer", ANARI_RENDERER},
          {"camera", ANARI_CAMERA},
          {"size", ANARI_UINT32_VEC2},
          {"channel.color", ANARI_DATA_TYPE},
          {"channel.depth", ANARI_DATA_TYPE},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 10: // channel
    if (infoType == ANARI_STRING_LIST) {
      static const char *channel[] = {"channel.color", "channel.depth", 0};
      return channel;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "group object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"surface", ANARI_ARRAY1D},
          {"volume", ANARI_ARRAY1D},
          {"light", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "world object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"instance", ANARI_ARRAY1D},
          {"surface", ANARI_ARRAY1D},
          {"volume", ANARI_ARRAY1D},
          {"light", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "surface object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"geometry", ANARI_GEOMETRY},
          {"material", ANARI_MATERIAL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "orthographic camera object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"up", ANARI_FLOAT32_VEC3},
          {"imageRegion", ANARI_FLOAT32_BOX2},
          {"aspect", ANARI_FLOAT32},
          {"height", ANARI_FLOAT32},
          {"near", ANARI_FLOAT32},
          {"far", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 4;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "perspective camera object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"up", ANARI_FLOAT32_VEC3},
          {"imageRegion", ANARI_FLOAT32_BOX2},
          {"fovy", ANARI_FLOAT32},
          {"aspect", ANARI_FLOAT32},
          {"near", ANARI_FLOAT32},
          {"far", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 5;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "cone geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.cap", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"caps", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 6;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "curve geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 7;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "cylinder geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.cap", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"primitive.radius", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {"caps", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 8;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "quad geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.normal", ANARI_ARRAY1D},
          {"vertex.tangent", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 9;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "sphere geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 10;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "triangle geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.normal", ANARI_ARRAY1D},
          {"vertex.tangent", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 11;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "directional light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"irradiance", ANARI_FLOAT32},
          {"direction", ANARI_FLOAT32_VEC3},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 12;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "point light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 13;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "spot light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"openingAngle", ANARI_FLOAT32},
          {"falloffAngle", ANARI_FLOAT32},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 14;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "matte material object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"color", ANARI_SAMPLER},
          {"color", ANARI_STRING},
          {"opacity", ANARI_FLOAT32},
          {"opacity", ANARI_SAMPLER},
          {"opacity", ANARI_STRING},
          {"alphaMode", ANARI_STRING},
          {"alphaCutoff", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 15;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "physically based material object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"baseColor", ANARI_FLOAT32_VEC3},
          {"baseColor", ANARI_SAMPLER},
          {"baseColor", ANARI_STRING},
          {"opacity", ANARI_FLOAT32},
          {"opacity", ANARI_SAMPLER},
          {"opacity", ANARI_STRING},
          {"metallic", ANARI_FLOAT32},
          {"metallic", ANARI_SAMPLER},
          {"metallic", ANARI_STRING},
          {"roughness", ANARI_FLOAT32},
          {"roughness", ANARI_SAMPLER},
          {"roughness", ANARI_STRING},
          {"normal", ANARI_SAMPLER},
          {"emissive", ANARI_FLOAT32_VEC3},
          {"emissive", ANARI_SAMPLER},
          {"emissive", ANARI_STRING},
          {"occlusion", ANARI_SAMPLER},
          {"alphaMode", ANARI_STRING},
          {"alphaCutoff", ANARI_FLOAT32},
          {"specular", ANARI_FLOAT32},
          {"specular", ANARI_SAMPLER},
          {"specular", ANARI_STRING},
          {"specularColor", ANARI_FLOAT32_VEC3},
          {"specularColor", ANARI_SAMPLER},
          {"specularColor", ANARI_STRING},
          {"clearcoat", ANARI_FLOAT32},
          {"clearcoat", ANARI_SAMPLER},
          {"clearcoat", ANARI_STRING},
          {"clearcoatRoughness", ANARI_FLOAT32},
          {"clearcoatRoughness", ANARI_SAMPLER},
          {"clearcoatRoughness", ANARI_STRING},
          {"clearcoatNormal", ANARI_SAMPLER},
          {"transmission", ANARI_FLOAT32},
          {"transmission", ANARI_SAMPLER},
          {"transmission", ANARI_STRING},
          {"ior", ANARI_FLOAT32},
          {"ior", ANARI_SAMPLER},
          {"ior", ANARI_STRING},
          {"thickness", ANARI_FLOAT32},
          {"thickness", ANARI_SAMPLER},
          {"thickness", ANARI_STRING},
          {"attenuationDistance", ANARI_FLOAT32},
          {"attenuationColor", ANARI_FLOAT32_VEC3},
          {"sheenColor", ANARI_FLOAT32_VEC3},
          {"sheenColor", ANARI_SAMPLER},
          {"sheenColor", ANARI_STRING},
          {"sheenRoughness", ANARI_FLOAT32},
          {"sheenRoughness", ANARI_SAMPLER},
          {"sheenRoughness", ANARI_STRING},
          {"iridescence", ANARI_FLOAT32},
          {"iridescence", ANARI_SAMPLER},
          {"iridescence", ANARI_STRING},
          {"iridescenceIor", ANARI_FLOAT32},
          {"iridescenceThickness", ANARI_FLOAT32},
          {"iridescenceThickness", ANARI_SAMPLER},
          {"iridescenceThickness", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 16;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "image1D object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"image", ANARI_ARRAY1D},
          {"inAttribute", ANARI_STRING},
          {"filter", ANARI_STRING},
          {"wrapMode1", ANARI_STRING},
          {"inTransform", ANARI_FLOAT32_MAT4},
          {"inOffset", ANARI_FLOAT32_VEC4},
          {"outTransform", ANARI_FLOAT32_MAT4},
          {"outOffset", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 17;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "image2D object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"image", ANARI_ARRAY2D},
          {"inAttribute", ANARI_STRING},
          {"filter", ANARI_STRING},
          {"wrapMode1", ANARI_STRING},
          {"wrapMode2", ANARI_STRING},
          {"inTransform", ANARI_FLOAT32_MAT4},
          {"inOffset", ANARI_FLOAT32_VEC4},
          {"outTransform", ANARI_FLOAT32_MAT4},
          {"outOffset", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 18;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "structured regular spatial field object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"data", ANARI_ARRAY3D},
          {"origin", ANARI_FLOAT32_VEC3},
          {"spacing", ANARI_FLOAT32_VEC3},
          {"filter", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 19;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "transferFunction1D volume object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"value", ANARI_SPATIAL_FIELD},
          {"valueRange", ANARI_FLOAT32_BOX1},
          {"valueRange", ANARI_FLOAT64_BOX1},
          {"color", ANARI_FLOAT32_VEC4},
          {"color", ANARI_FLOAT32_VEC3},
          {"color", ANARI_ARRAY1D},
          {"opacity", ANARI_FLOAT32},
          {"opacity", ANARI_ARRAY1D},
          {"unitDistance", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 20;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 9:
    return ANARI_CAMERA_orthographic_info(infoName, infoType);
  case 11:
    return ANARI_CAMERA_perspective_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 0:
    return ANARI_GEOMETRY_cone_info(infoName, infoType);
  case 1:
    return ANARI_GEOMETRY_curve_info(infoName, infoType);
  case 2:
    return ANARI_GEOMETRY_cylinder_info(infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_quad_info(infoName, infoType);
  case 16:
    return ANARI_GEOMETRY_sphere_info(infoName, infoType);
  case 20:
    return ANARI_GEOMETRY_triangle_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 5:
    return ANARI_LIGHT_directional_info(infoName, infoType);
  case 13:
    return ANARI_LIGHT_point_info(infoName, infoType);
  case 17:
    return ANARI_LIGHT_spot_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 8:
    return ANARI_MATERIAL_matte_info(infoName, infoType);
  case 12:
    return ANARI_MATERIAL_physicallyBased_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 4:
    return ANARI_RENDERER_default_info(infoName, infoType);
  case 10:
    return ANARI_RENDERER_pathtracer_info(infoName, infoType);
  case 15:
    return ANARI_RENDERER_scivis_info(infoName, infoType);
  case 3:
    return ANARI_RENDERER_debug_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 6:
    return ANARI_SAMPLER_image1D_info(infoName, infoType);
  case 7:
    return ANARI_SAMPLER_image2D_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 18:
    return ANARI_SPATIAL_FIELD_structuredRegular_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 19:
    return ANARI_VOLUME_transferFunction1D_info(infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_object_info_enum(ANARIDataType type,
    const char *subtype,
    int infoName,
    ANARIDataType infoType)
{
  switch (type) {
  case ANARI_CAMERA:
    return ANARI_CAMERA_info(subtype, infoName, infoType);
  case ANARI_GEOMETRY:
    return ANARI_GEOMETRY_info(subtype, infoName, infoType);
  case ANARI_LIGHT:
    return ANARI_LIGHT_info(subtype, infoName, infoType);
  case ANARI_MATERIAL:
    return ANARI_MATERIAL_info(subtype, infoName, infoType);
  case ANARI_RENDERER:
    return ANARI_RENDERER_info(subtype, infoName, infoType);
  case ANARI_SAMPLER:
    return ANARI_SAMPLER_info(subtype, infoName, infoType);
  case ANARI_SPATIAL_FIELD:
    return ANARI_SPATIAL_FIELD_info(subtype, infoName, infoType);
  case ANARI_VOLUME:
    return ANARI_VOLUME_info(subtype, infoName, infoType);
  case ANARI_DEVICE:
    return ANARI_DEVICE_info(infoName, infoType);
  case ANARI_ARRAY1D:
    return ANARI_ARRAY1D_info(infoName, infoType);
  case ANARI_ARRAY2D:
    return ANARI_ARRAY2D_info(infoName, infoType);
  case ANARI_ARRAY3D:
    return ANARI_ARRAY3D_info(infoName, infoType);
  case ANARI_FRAME:
    return ANARI_FRAME_info(infoName, infoType);
  case ANARI_GROUP:
    return ANARI_GROUP_info(infoName, infoType);
  case ANARI_WORLD:
    return ANARI_WORLD_info(infoName, infoType);
  case ANARI_SURFACE:
    return ANARI_SURFACE_info(infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_object_info(ANARIDataType type,
    const char *subtype,
    const char *infoNameString,
    ANARIDataType infoType)
{
  int infoName = info_hash(infoNameString);
  return query_object_info_enum(type, subtype, infoName, infoType);
}
} // namespace anari_ospray
