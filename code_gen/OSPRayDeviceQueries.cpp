// Copyright 2024 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_queries.py
// Don't make changes to this directly

#include <anari/anari.h>
#include <math.h>
#include <stdint.h>
namespace anari_ospray {
static int subtype_hash(const char *str)
{
  static const uint32_t table[] = {0x7a6f0012u,
      0x6a65002bu,
      0x0u,
      0x0u,
      0x0u,
      0x65640047u,
      0x746d004bu,
      0x0u,
      0x0u,
      0x0u,
      0x62610064u,
      0x0u,
      0x73720069u,
      0x70610075u,
      0x767500a9u,
      0x6a6900adu,
      0x756300b1u,
      0x737200e6u,
      0x6f6e001du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720020u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c0024u,
      0x6665001eu,
      0x100001fu,
      0x80000000u,
      0x77760021u,
      0x66650022u,
      0x1000023u,
      0x80000001u,
      0x6a690025u,
      0x6f6e0026u,
      0x65640027u,
      0x66650028u,
      0x73720029u,
      0x100002au,
      0x80000002u,
      0x67620030u,
      0x0u,
      0x0u,
      0x0u,
      0x7372003du,
      0x76750035u,
      0x0u,
      0x0u,
      0x0u,
      0x62610038u,
      0x68670036u,
      0x1000037u,
      0x80000003u,
      0x76750039u,
      0x6d6c003au,
      0x7574003bu,
      0x100003cu,
      0x80000004u,
      0x6665003eu,
      0x6463003fu,
      0x75740040u,
      0x6a690041u,
      0x706f0042u,
      0x6f6e0043u,
      0x62610044u,
      0x6d6c0045u,
      0x1000046u,
      0x80000005u,
      0x73720048u,
      0x6a690049u,
      0x100004au,
      0x80000006u,
      0x62610052u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f005bu,
      0x68670053u,
      0x66650054u,
      0x33310055u,
      0x45440057u,
      0x45440059u,
      0x1000058u,
      0x80000007u,
      0x100005au,
      0x80000008u,
      0x7473005cu,
      0x7675005du,
      0x7372005eu,
      0x6766005fu,
      0x62610060u,
      0x64630061u,
      0x66650062u,
      0x1000063u,
      0x80000009u,
      0x75740065u,
      0x75740066u,
      0x66650067u,
      0x1000068u,
      0x8000000au,
      0x7574006au,
      0x6968006bu,
      0x706f006cu,
      0x6867006du,
      0x7372006eu,
      0x6261006fu,
      0x71700070u,
      0x69680071u,
      0x6a690072u,
      0x64630073u,
      0x1000074u,
      0x8000000bu,
      0x75740084u,
      0x0u,
      0x0u,
      0x0u,
      0x7372008du,
      0x0u,
      0x0u,
      0x7a790097u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a6900a5u,
      0x69680085u,
      0x75740086u,
      0x73720087u,
      0x62610088u,
      0x64630089u,
      0x6665008au,
      0x7372008bu,
      0x100008cu,
      0x8000000cu,
      0x7473008eu,
      0x7170008fu,
      0x66650090u,
      0x64630091u,
      0x75740092u,
      0x6a690093u,
      0x77760094u,
      0x66650095u,
      0x1000096u,
      0x8000000du,
      0x74730098u,
      0x6a690099u,
      0x6463009au,
      0x6261009bu,
      0x6d6c009cu,
      0x6d6c009du,
      0x7a79009eu,
      0x4342009fu,
      0x626100a0u,
      0x747300a1u,
      0x666500a2u,
      0x656400a3u,
      0x10000a4u,
      0x8000000eu,
      0x6f6e00a6u,
      0x757400a7u,
      0x10000a8u,
      0x8000000fu,
      0x626100aau,
      0x656400abu,
      0x10000acu,
      0x80000010u,
      0x6f6e00aeu,
      0x686700afu,
      0x10000b0u,
      0x80000011u,
      0x6a6900c3u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706800c8u,
      0x0u,
      0x0u,
      0x0u,
      0x737200d6u,
      0x777600c4u,
      0x6a6900c5u,
      0x747300c6u,
      0x10000c7u,
      0x80000012u,
      0x666500d0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x757400d4u,
      0x737200d1u,
      0x666500d2u,
      0x10000d3u,
      0x80000013u,
      0x10000d5u,
      0x80000014u,
      0x767500d7u,
      0x646300d8u,
      0x757400d9u,
      0x767500dau,
      0x737200dbu,
      0x666500dcu,
      0x656400ddu,
      0x535200deu,
      0x666500dfu,
      0x686700e0u,
      0x767500e1u,
      0x6d6c00e2u,
      0x626100e3u,
      0x737200e4u,
      0x10000e5u,
      0x80000015u,
      0x6a6100e7u,
      0x6f6e00f0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610100u,
      0x747300f1u,
      0x676600f2u,
      0x666500f3u,
      0x737200f4u,
      0x474600f5u,
      0x767500f6u,
      0x6f6e00f7u,
      0x646300f8u,
      0x757400f9u,
      0x6a6900fau,
      0x706f00fbu,
      0x6f6e00fcu,
      0x323100fdu,
      0x454400feu,
      0x10000ffu,
      0x80000016u,
      0x6f6e0101u,
      0x68670102u,
      0x6d6c0103u,
      0x66650104u,
      0x1000105u,
      0x80000017u};
  uint32_t cur = 0x75630000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static int param_hash(const char *str)
{
  static const uint32_t table[] = {0x756c0017u,
      0x626100d5u,
      0x70300152u,
      0x6a61021cu,
      0x6e640230u,
      0x70610247u,
      0x6665027au,
      0x66650282u,
      0x746d0288u,
      0x0u,
      0x0u,
      0x6a610435u,
      0x6a6104a1u,
      0x7061050bu,
      0x76630525u,
      0x7369056fu,
      0x0u,
      0x706105d7u,
      0x76630626u,
      0x7368074au,
      0x716e0768u,
      0x70610777u,
      0x736f090bu,
      0x716c0020u,
      0x6362004fu,
      0x68670071u,
      0x5444007fu,
      0x0u,
      0x0u,
      0x0u,
      0x7170009eu,
      0x757400a3u,
      0x706f0025u,
      0x0u,
      0x0u,
      0x0u,
      0x69680038u,
      0x78770026u,
      0x4a490027u,
      0x6f6e0028u,
      0x77760029u,
      0x6261002au,
      0x6d6c002bu,
      0x6a69002cu,
      0x6564002du,
      0x4e4d002eu,
      0x6261002fu,
      0x75740030u,
      0x66650031u,
      0x73720032u,
      0x6a690033u,
      0x62610034u,
      0x6d6c0035u,
      0x74730036u,
      0x1000037u,
      0x80000000u,
      0x62610039u,
      0x4e43003au,
      0x76750045u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f004bu,
      0x75740046u,
      0x706f0047u,
      0x67660048u,
      0x67660049u,
      0x100004au,
      0x80000001u,
      0x6564004cu,
      0x6665004du,
      0x100004eu,
      0x80000002u,
      0x6a690050u,
      0x66650051u,
      0x6f6e0052u,
      0x75740053u,
      0x53430054u,
      0x706f0064u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610069u,
      0x6d6c0065u,
      0x706f0066u,
      0x73720067u,
      0x1000068u,
      0x80000003u,
      0x6564006au,
      0x6a69006bu,
      0x6261006cu,
      0x6f6e006du,
      0x6463006eu,
      0x6665006fu,
      0x1000070u,
      0x80000004u,
      0x76750072u,
      0x6d6c0073u,
      0x62610074u,
      0x73720075u,
      0x45440076u,
      0x6a690077u,
      0x62610078u,
      0x6e6d0079u,
      0x6665007au,
      0x7574007bu,
      0x6665007cu,
      0x7372007du,
      0x100007eu,
      0x80000005u,
      0x6a69008fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610097u,
      0x74730090u,
      0x75740091u,
      0x62610092u,
      0x6f6e0093u,
      0x64630094u,
      0x66650095u,
      0x1000096u,
      0x80000006u,
      0x6e6d0098u,
      0x71700099u,
      0x6d6c009au,
      0x6665009bu,
      0x7473009cu,
      0x100009du,
      0x80000007u,
      0x6665009fu,
      0x646300a0u,
      0x757400a1u,
      0x10000a2u,
      0x80000008u,
      0x736500a4u,
      0x6f6e00b2u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a6900c8u,
      0x767500b3u,
      0x626100b4u,
      0x757400b5u,
      0x6a6900b6u,
      0x706f00b7u,
      0x6f6e00b8u,
      0x454300b9u,
      0x706f00bbu,
      0x6a6900c0u,
      0x6d6c00bcu,
      0x706f00bdu,
      0x737200beu,
      0x10000bfu,
      0x80000009u,
      0x747300c1u,
      0x757400c2u,
      0x626100c3u,
      0x6f6e00c4u,
      0x646300c5u,
      0x666500c6u,
      0x10000c7u,
      0x8000000au,
      0x636200c9u,
      0x767500cau,
      0x757400cbu,
      0x666500ccu,
      0x343000cdu,
      0x10000d1u,
      0x10000d2u,
      0x10000d3u,
      0x10000d4u,
      0x8000000bu,
      0x8000000cu,
      0x8000000du,
      0x8000000eu,
      0x746300d6u,
      0x6c6b00e7u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6665014bu,
      0x686700e8u,
      0x737200e9u,
      0x706f00eau,
      0x767500ebu,
      0x6f6e00ecu,
      0x656400edu,
      0x530000eeu,
      0x8000000fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66650141u,
      0x67660142u,
      0x73720143u,
      0x62610144u,
      0x64630145u,
      0x75740146u,
      0x6a690147u,
      0x706f0148u,
      0x6f6e0149u,
      0x100014au,
      0x80000010u,
      0x4443014cu,
      0x706f014du,
      0x6d6c014eu,
      0x706f014fu,
      0x73720150u,
      0x1000151u,
      0x80000011u,
      0x1000192u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x716d0193u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6261019du,
      0x0u,
      0x0u,
      0x0u,
      0x666501afu,
      0x0u,
      0x0u,
      0x6d6c0218u,
      0x80000012u,
      0x66650197u,
      0x0u,
      0x0u,
      0x7473019bu,
      0x73720198u,
      0x62610199u,
      0x100019au,
      0x80000013u,
      0x100019cu,
      0x80000014u,
      0x6f6e019eu,
      0x6f6e019fu,
      0x666501a0u,
      0x6d6c01a1u,
      0x2f2e01a2u,
      0x656301a3u,
      0x706f01a5u,
      0x666501aau,
      0x6d6c01a6u,
      0x706f01a7u,
      0x737201a8u,
      0x10001a9u,
      0x80000015u,
      0x717001abu,
      0x757401acu,
      0x696801adu,
      0x10001aeu,
      0x80000016u,
      0x626101b0u,
      0x737201b1u,
      0x646301b2u,
      0x706f01b3u,
      0x626101b4u,
      0x757401b5u,
      0x530001b6u,
      0x80000017u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f0209u,
      0x0u,
      0x0u,
      0x0u,
      0x706f020fu,
      0x7372020au,
      0x6e6d020bu,
      0x6261020cu,
      0x6d6c020du,
      0x100020eu,
      0x80000018u,
      0x76750210u,
      0x68670211u,
      0x69680212u,
      0x6f6e0213u,
      0x66650214u,
      0x74730215u,
      0x74730216u,
      0x1000217u,
      0x80000019u,
      0x706f0219u,
      0x7372021au,
      0x100021bu,
      0x8000001au,
      0x75740225u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720228u,
      0x62610226u,
      0x1000227u,
      0x8000001bu,
      0x66650229u,
      0x6463022au,
      0x7574022bu,
      0x6a69022cu,
      0x706f022du,
      0x6f6e022eu,
      0x100022fu,
      0x8000001cu,
      0x6867023au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a690240u,
      0x6665023bu,
      0x3331023cu,
      0x100023eu,
      0x100023fu,
      0x8000001du,
      0x8000001eu,
      0x74730241u,
      0x74730242u,
      0x6a690243u,
      0x77760244u,
      0x66650245u,
      0x1000246u,
      0x8000001fu,
      0x736c0256u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d650268u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x77760277u,
      0x6d6c025du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x1000267u,
      0x706f025eu,
      0x6766025fu,
      0x67660260u,
      0x42410261u,
      0x6f6e0262u,
      0x68670263u,
      0x6d6c0264u,
      0x66650265u,
      0x1000266u,
      0x80000020u,
      0x80000021u,
      0x6d6c0270u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x75740273u,
      0x65640271u,
      0x1000272u,
      0x80000022u,
      0x66650274u,
      0x73720275u,
      0x1000276u,
      0x80000023u,
      0x7a790278u,
      0x1000279u,
      0x80000024u,
      0x706f027bu,
      0x6e6d027cu,
      0x6665027du,
      0x7574027eu,
      0x7372027fu,
      0x7a790280u,
      0x1000281u,
      0x80000025u,
      0x6a690283u,
      0x68670284u,
      0x69680285u,
      0x75740286u,
      0x1000287u,
      0x80000026u,
      0x6261028fu,
      0x774102ebu,
      0x737203b1u,
      0x0u,
      0x0u,
      0x736903b3u,
      0x706f042eu,
      0x68670290u,
      0x66650291u,
      0x53000292u,
      0x80000027u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x666502e5u,
      0x686702e6u,
      0x6a6902e7u,
      0x706f02e8u,
      0x6f6e02e9u,
      0x10002eau,
      0x80000028u,
      0x75740321u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6766032au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720330u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66650339u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x75740342u,
      0x66650348u,
      0x0u,
      0x6261039fu,
      0x75740322u,
      0x73720323u,
      0x6a690324u,
      0x63620325u,
      0x76750326u,
      0x75740327u,
      0x66650328u,
      0x1000329u,
      0x80000029u,
      0x6766032bu,
      0x7473032cu,
      0x6665032du,
      0x7574032eu,
      0x100032fu,
      0x8000002au,
      0x62610331u,
      0x6f6e0332u,
      0x74730333u,
      0x67660334u,
      0x706f0335u,
      0x73720336u,
      0x6e6d0337u,
      0x1000338u,
      0x8000002bu,
      0x7372033au,
      0x5352033bu,
      0x6261033cu,
      0x6564033du,
      0x6a69033eu,
      0x7675033fu,
      0x74730340u,
      0x1000341u,
      0x8000002cu,
      0x62610343u,
      0x6f6e0344u,
      0x64630345u,
      0x66650346u,
      0x1000347u,
      0x8000002du,
      0x6f6e0349u,
      0x7473034au,
      0x6a69034bu,
      0x7574034cu,
      0x7a79034du,
      0x4500034eu,
      0x8000002eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a690393u,
      0x74730394u,
      0x75740395u,
      0x73720396u,
      0x6a690397u,
      0x63620398u,
      0x76750399u,
      0x7574039au,
      0x6a69039bu,
      0x706f039cu,
      0x6f6e039du,
      0x100039eu,
      0x8000002fu,
      0x6d6c03a0u,
      0x6a6903a1u,
      0x656403a2u,
      0x4e4d03a3u,
      0x626103a4u,
      0x757403a5u,
      0x666503a6u,
      0x737203a7u,
      0x6a6903a8u,
      0x626103a9u,
      0x6d6c03aau,
      0x444303abu,
      0x706f03acu,
      0x6d6c03adu,
      0x706f03aeu,
      0x737203afu,
      0x10003b0u,
      0x80000030u,
      0x10003b2u,
      0x80000031u,
      0x656403bdu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610426u,
      0x666503beu,
      0x747303bfu,
      0x646303c0u,
      0x666503c1u,
      0x6f6e03c2u,
      0x646303c3u,
      0x666503c4u,
      0x550003c5u,
      0x80000032u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f041au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6968041du,
      0x7372041bu,
      0x100041cu,
      0x80000033u,
      0x6a69041eu,
      0x6463041fu,
      0x6c6b0420u,
      0x6f6e0421u,
      0x66650422u,
      0x74730423u,
      0x74730424u,
      0x1000425u,
      0x80000034u,
      0x65640427u,
      0x6a690428u,
      0x62610429u,
      0x6f6e042au,
      0x6463042bu,
      0x6665042cu,
      0x100042du,
      0x80000035u,
      0x7776042fu,
      0x62610430u,
      0x6d6c0431u,
      0x76750432u,
      0x66650433u,
      0x1000434u,
      0x80000036u,
      0x7a79043eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x68670443u,
      0x706f043fu,
      0x76750440u,
      0x75740441u,
      0x1000442u,
      0x80000037u,
      0x69680444u,
      0x75740445u,
      0x54000446u,
      0x80000038u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6261049au,
      0x6e6d049bu,
      0x7170049cu,
      0x6d6c049du,
      0x6665049eu,
      0x7473049fu,
      0x10004a0u,
      0x80000039u,
      0x797404aau,
      0x0u,
      0x0u,
      0x0u,
      0x757404ecu,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e04fdu,
      0x666504afu,
      0x0u,
      0x0u,
      0x0u,
      0x544304b5u,
      0x737204b0u,
      0x6a6904b1u,
      0x626104b2u,
      0x6d6c04b3u,
      0x10004b4u,
      0x8000003au,
      0x706f04c6u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626104d2u,
      0x0u,
      0x0u,
      0x646304dcu,
      0x6f6e04c7u,
      0x757404c8u,
      0x737204c9u,
      0x6a6904cau,
      0x636204cbu,
      0x767504ccu,
      0x757404cdu,
      0x6a6904ceu,
      0x706f04cfu,
      0x6f6e04d0u,
      0x10004d1u,
      0x8000003bu,
      0x757404d3u,
      0x696804d4u,
      0x4d4c04d5u,
      0x666504d6u,
      0x6f6e04d7u,
      0x686704d8u,
      0x757404d9u,
      0x696804dau,
      0x10004dbu,
      0x8000003cu,
      0x626104ddu,
      0x757404deu,
      0x757404dfu,
      0x666504e0u,
      0x737204e1u,
      0x6a6904e2u,
      0x6f6e04e3u,
      0x686704e4u,
      0x464504e5u,
      0x777604e6u,
      0x666504e7u,
      0x6f6e04e8u,
      0x757404e9u,
      0x747304eau,
      0x10004ebu,
      0x8000003du,
      0x696104edu,
      0x6d6c04f5u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f04fau,
      0x6d6c04f6u,
      0x6a6904f7u,
      0x646304f8u,
      0x10004f9u,
      0x8000003eu,
      0x656404fbu,
      0x10004fcu,
      0x8000003fu,
      0x444304feu,
      0x706f04ffu,
      0x6f6e0500u,
      0x75740501u,
      0x73720502u,
      0x6a690503u,
      0x63620504u,
      0x76750505u,
      0x75740506u,
      0x6a690507u,
      0x706f0508u,
      0x6f6e0509u,
      0x100050au,
      0x80000040u,
      0x6e6d051au,
      0x0u,
      0x0u,
      0x0u,
      0x6261051du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720520u,
      0x6665051bu,
      0x100051cu,
      0x80000041u,
      0x7372051eu,
      0x100051fu,
      0x80000042u,
      0x6e6d0521u,
      0x62610522u,
      0x6d6c0523u,
      0x1000524u,
      0x80000043u,
      0x64630538u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66610540u,
      0x0u,
      0x6a690554u,
      0x0u,
      0x0u,
      0x75740559u,
      0x6d6c0539u,
      0x7675053au,
      0x7473053bu,
      0x6a69053cu,
      0x706f053du,
      0x6f6e053eu,
      0x100053fu,
      0x80000044u,
      0x64630545u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e054au,
      0x6a690546u,
      0x75740547u,
      0x7a790548u,
      0x1000549u,
      0x80000045u,
      0x6a69054bu,
      0x6f6e054cu,
      0x6867054du,
      0x4241054eu,
      0x6f6e054fu,
      0x68670550u,
      0x6d6c0551u,
      0x66650552u,
      0x1000553u,
      0x80000046u,
      0x68670555u,
      0x6a690556u,
      0x6f6e0557u,
      0x1000558u,
      0x80000047u,
      0x554f055au,
      0x67660560u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720566u,
      0x67660561u,
      0x74730562u,
      0x66650563u,
      0x75740564u,
      0x1000565u,
      0x80000048u,
      0x62610567u,
      0x6f6e0568u,
      0x74730569u,
      0x6766056au,
      0x706f056bu,
      0x7372056cu,
      0x6e6d056du,
      0x100056eu,
      0x80000049u,
      0x79780579u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x78730584u,
      0x0u,
      0x0u,
      0x6a690592u,
      0x6665057au,
      0x6d6c057bu,
      0x5453057cu,
      0x6261057du,
      0x6e6d057eu,
      0x7170057fu,
      0x6d6c0580u,
      0x66650581u,
      0x74730582u,
      0x1000583u,
      0x8000004au,
      0x6a690589u,
      0x0u,
      0x0u,
      0x0u,
      0x6665058fu,
      0x7574058au,
      0x6a69058bu,
      0x706f058cu,
      0x6f6e058du,
      0x100058eu,
      0x8000004bu,
      0x73720590u,
      0x1000591u,
      0x8000004cu,
      0x6e6d0593u,
      0x6a690594u,
      0x75740595u,
      0x6a690596u,
      0x77760597u,
      0x66650598u,
      0x2f2e0599u,
      0x7361059au,
      0x757405acu,
      0x0u,
      0x706f05bcu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6405c1u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626105d1u,
      0x757405adu,
      0x737205aeu,
      0x6a6905afu,
      0x636205b0u,
      0x767505b1u,
      0x757405b2u,
      0x666505b3u,
      0x343005b4u,
      0x10005b8u,
      0x10005b9u,
      0x10005bau,
      0x10005bbu,
      0x8000004du,
      0x8000004eu,
      0x8000004fu,
      0x80000050u,
      0x6d6c05bdu,
      0x706f05beu,
      0x737205bfu,
      0x10005c0u,
      0x80000051u,
      0x10005ccu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x656405cdu,
      0x80000052u,
      0x666505ceu,
      0x797805cfu,
      0x10005d0u,
      0x80000053u,
      0x656405d2u,
      0x6a6905d3u,
      0x767505d4u,
      0x747305d5u,
      0x10005d6u,
      0x80000054u,
      0x656405e6u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0603u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7675060au,
      0x6a6905e7u,
      0x766105e8u,
      0x6f6e05fdu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x74730601u,
      0x646305feu,
      0x666505ffu,
      0x1000600u,
      0x80000055u,
      0x1000602u,
      0x80000056u,
      0x65640604u,
      0x66650605u,
      0x73720606u,
      0x66650607u,
      0x73720608u,
      0x1000609u,
      0x80000057u,
      0x6d67060bu,
      0x69680611u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66650617u,
      0x6f6e0612u,
      0x66650613u,
      0x74730614u,
      0x74730615u,
      0x1000616u,
      0x80000058u,
      0x75740618u,
      0x75740619u,
      0x6665061au,
      0x5150061bu,
      0x6261061cu,
      0x7574061du,
      0x6968061eu,
      0x4d4c061fu,
      0x66650620u,
      0x6f6e0621u,
      0x68670622u,
      0x75740623u,
      0x69680624u,
      0x1000625u,
      0x80000059u,
      0x62610639u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6661063du,
      0x7b640667u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66610682u,
      0x0u,
      0x0u,
      0x0u,
      0x626106dau,
      0x73720744u,
      0x6d6c063au,
      0x6665063bu,
      0x100063cu,
      0x8000005au,
      0x65640642u,
      0x0u,
      0x0u,
      0x0u,
      0x66650647u,
      0x706f0643u,
      0x78770644u,
      0x74730645u,
      0x1000646u,
      0x8000005bu,
      0x6f6e0648u,
      0x53430649u,
      0x706f0659u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f065eu,
      0x6d6c065au,
      0x706f065bu,
      0x7372065cu,
      0x100065du,
      0x8000005cu,
      0x7675065fu,
      0x68670660u,
      0x69680661u,
      0x6f6e0662u,
      0x66650663u,
      0x74730664u,
      0x74730665u,
      0x1000666u,
      0x8000005du,
      0x6665067eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66650680u,
      0x100067fu,
      0x8000005eu,
      0x1000681u,
      0x8000005fu,
      0x64630687u,
      0x0u,
      0x0u,
      0x0u,
      0x6463068cu,
      0x6a690688u,
      0x6f6e0689u,
      0x6867068au,
      0x100068bu,
      0x80000060u,
      0x7675068du,
      0x6d6c068eu,
      0x6261068fu,
      0x73720690u,
      0x44000691u,
      0x80000061u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f06d5u,
      0x6d6c06d6u,
      0x706f06d7u,
      0x737206d8u,
      0x10006d9u,
      0x80000062u,
      0x757406dbu,
      0x767506dcu,
      0x747306ddu,
      0x444306deu,
      0x626106dfu,
      0x6d6c06e0u,
      0x6d6c06e1u,
      0x636206e2u,
      0x626106e3u,
      0x646306e4u,
      0x6c6b06e5u,
      0x560006e6u,
      0x80000063u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7473073cu,
      0x6665073du,
      0x7372073eu,
      0x4544073fu,
      0x62610740u,
      0x75740741u,
      0x62610742u,
      0x1000743u,
      0x80000064u,
      0x67660745u,
      0x62610746u,
      0x64630747u,
      0x66650748u,
      0x1000749u,
      0x80000065u,
      0x6a690755u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6261075du,
      0x64630756u,
      0x6c6b0757u,
      0x6f6e0758u,
      0x66650759u,
      0x7473075au,
      0x7473075bu,
      0x100075cu,
      0x80000066u,
      0x6f6e075eu,
      0x7473075fu,
      0x6e6d0760u,
      0x6a690761u,
      0x74730762u,
      0x74730763u,
      0x6a690764u,
      0x706f0765u,
      0x6f6e0766u,
      0x1000767u,
      0x80000067u,
      0x6a69076bu,
      0x0u,
      0x1000776u,
      0x7574076cu,
      0x4544076du,
      0x6a69076eu,
      0x7473076fu,
      0x75740770u,
      0x62610771u,
      0x6f6e0772u,
      0x64630773u,
      0x66650774u,
      0x1000775u,
      0x80000068u,
      0x80000069u,
      0x736c0786u,
      0x0u,
      0x0u,
      0x0u,
      0x737207f6u,
      0x0u,
      0x0u,
      0x0u,
      0x7473084fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c08a7u,
      0x7675078du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a6907e7u,
      0x6665078eu,
      0x5300078fu,
      0x8000006au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626107e2u,
      0x6f6e07e3u,
      0x686707e4u,
      0x666507e5u,
      0x10007e6u,
      0x8000006bu,
      0x626107e8u,
      0x6f6e07e9u,
      0x646307eau,
      0x666507ebu,
      0x555407ecu,
      0x696807edu,
      0x737207eeu,
      0x666507efu,
      0x747307f0u,
      0x696807f1u,
      0x706f07f2u,
      0x6d6c07f3u,
      0x656407f4u,
      0x10007f5u,
      0x8000006cu,
      0x757407f7u,
      0x666507f8u,
      0x797807f9u,
      0x2f2e07fau,
      0x756107fbu,
      0x7574080fu,
      0x0u,
      0x7061081fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f0834u,
      0x0u,
      0x706f083au,
      0x0u,
      0x62610842u,
      0x0u,
      0x62610848u,
      0x75740810u,
      0x73720811u,
      0x6a690812u,
      0x63620813u,
      0x76750814u,
      0x75740815u,
      0x66650816u,
      0x34300817u,
      0x100081bu,
      0x100081cu,
      0x100081du,
      0x100081eu,
      0x8000006du,
      0x8000006eu,
      0x8000006fu,
      0x80000070u,
      0x7170082eu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c0830u,
      0x100082fu,
      0x80000071u,
      0x706f0831u,
      0x73720832u,
      0x1000833u,
      0x80000072u,
      0x73720835u,
      0x6e6d0836u,
      0x62610837u,
      0x6d6c0838u,
      0x1000839u,
      0x80000073u,
      0x7473083bu,
      0x6a69083cu,
      0x7574083du,
      0x6a69083eu,
      0x706f083fu,
      0x6f6e0840u,
      0x1000841u,
      0x80000074u,
      0x65640843u,
      0x6a690844u,
      0x76750845u,
      0x74730846u,
      0x1000847u,
      0x80000075u,
      0x6f6e0849u,
      0x6867084au,
      0x6665084bu,
      0x6f6e084cu,
      0x7574084du,
      0x100084eu,
      0x80000076u,
      0x6a690850u,
      0x63620851u,
      0x6d6c0852u,
      0x66650853u,
      0x4d000854u,
      0x80000077u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a6908a1u,
      0x686708a2u,
      0x696808a3u,
      0x757408a4u,
      0x747308a5u,
      0x10008a6u,
      0x80000078u,
      0x767508a8u,
      0x6e6d08a9u,
      0x666508aau,
      0x540008abu,
      0x80000079u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626108ffu,
      0x6e6d0900u,
      0x71700901u,
      0x6d6c0902u,
      0x6a690903u,
      0x6f6e0904u,
      0x68670905u,
      0x53520906u,
      0x62610907u,
      0x75740908u,
      0x66650909u,
      0x100090au,
      0x8000007au,
      0x7372090fu,
      0x0u,
      0x0u,
      0x62610913u,
      0x6d6c0910u,
      0x65640911u,
      0x1000912u,
      0x8000007bu,
      0x71700914u,
      0x4e4d0915u,
      0x706f0916u,
      0x65640917u,
      0x66650918u,
      0x33310919u,
      0x100091bu,
      0x100091cu,
      0x8000007cu,
      0x8000007du};
  uint32_t cur = 0x78610000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static int info_hash(const char *str)
{
  static const uint32_t table[] = {0x69680014u,
      0x6665001bu,
      0x796c0038u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a610057u,
      0x0u,
      0x0u,
      0x6261006cu,
      0x0u,
      0x66650075u,
      0x706f007du,
      0x0u,
      0x7473008cu,
      0x6261008fu,
      0x62610015u,
      0x6f6e0016u,
      0x6f6e0017u,
      0x66650018u,
      0x6d6c0019u,
      0x100001au,
      0x8000000au,
      0x7466001cu,
      0x6261002au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6463002fu,
      0x7675002bu,
      0x6d6c002cu,
      0x7574002du,
      0x100002eu,
      0x80000001u,
      0x73720030u,
      0x6a690031u,
      0x71700032u,
      0x75740033u,
      0x6a690034u,
      0x706f0035u,
      0x6f6e0036u,
      0x1000037u,
      0x80000004u,
      0x66650045u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7574004fu,
      0x6e6d0046u,
      0x66650047u,
      0x6f6e0048u,
      0x75740049u,
      0x5554004au,
      0x7a79004bu,
      0x7170004cu,
      0x6665004du,
      0x100004eu,
      0x80000005u,
      0x66650050u,
      0x6f6e0051u,
      0x74730052u,
      0x6a690053u,
      0x706f0054u,
      0x6f6e0055u,
      0x1000056u,
      0x80000008u,
      0x79780060u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0066u,
      0x6a690061u,
      0x6e6d0062u,
      0x76750063u,
      0x6e6d0064u,
      0x1000065u,
      0x80000003u,
      0x6a690067u,
      0x6e6d0068u,
      0x76750069u,
      0x6e6d006au,
      0x100006bu,
      0x80000002u,
      0x7372006du,
      0x6261006eu,
      0x6e6d006fu,
      0x66650070u,
      0x75740071u,
      0x66650072u,
      0x73720073u,
      0x1000074u,
      0x80000009u,
      0x72710076u,
      0x76750077u,
      0x6a690078u,
      0x73720079u,
      0x6665007au,
      0x6564007bu,
      0x100007cu,
      0x80000000u,
      0x7675007eu,
      0x7372007fu,
      0x64630080u,
      0x66650081u,
      0x46450082u,
      0x79780083u,
      0x75740084u,
      0x66650085u,
      0x6f6e0086u,
      0x74730087u,
      0x6a690088u,
      0x706f0089u,
      0x6f6e008au,
      0x100008bu,
      0x80000007u,
      0x6665008du,
      0x100008eu,
      0x8000000bu,
      0x6d6c0090u,
      0x76750091u,
      0x66650092u,
      0x1000093u,
      0x80000006u};
  uint32_t cur = 0x77630000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static const int32_t anari_true = 1;
static const int32_t anari_false = 0;
const char **query_extensions()
{
  static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
      "ANARI_KHR_LIGHT_POINT",
      "ANARI_KHR_LIGHT_RING",
      "ANARI_KHR_LIGHT_QUAD",
      "ANARI_KHR_LIGHT_HDRI",
      "ANARI_OSPRAY_RENDERER_DEFAULT",
      "ANARI_OSPRAY_RENDERER_PATHTRACER",
      "ANARI_OSPRAY_RENDERER_SCIVIS",
      "ANARI_OSPRAY_RENDERER_DEBUG",
      "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
      "ANARI_KHR_CAMERA_PERSPECTIVE",
      "ANARI_KHR_GEOMETRY_CONE",
      "ANARI_KHR_GEOMETRY_CURVE",
      "ANARI_KHR_GEOMETRY_CYLINDER",
      "ANARI_KHR_GEOMETRY_ISOSURFACE",
      "ANARI_KHR_GEOMETRY_QUAD",
      "ANARI_KHR_GEOMETRY_SPHERE",
      "ANARI_KHR_GEOMETRY_TRIANGLE",
      "ANARI_KHR_LIGHT_SPOT",
      "ANARI_KHR_AREA_LIGHTS",
      "ANARI_KHR_MATERIAL_MATTE",
      "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
      "ANARI_KHR_SAMPLER_IMAGE1D",
      "ANARI_KHR_SAMPLER_IMAGE2D",
      "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
      "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
      "ANARI_OSPRAY_EXTENSIONS",
      0};
  return extensions;
}
const char **query_object_types(ANARIDataType type)
{
  switch (type) {
  case ANARI_LIGHT: {
    static const char *ANARI_LIGHT_subtypes[] = {
        "directional", "point", "ring", "quad", "hdri", "spot", 0};
    return ANARI_LIGHT_subtypes;
  }
  case ANARI_RENDERER: {
    static const char *ANARI_RENDERER_subtypes[] = {
        "default", "pathtracer", "scivis", "debug", 0};
    return ANARI_RENDERER_subtypes;
  }
  case ANARI_CAMERA: {
    static const char *ANARI_CAMERA_subtypes[] = {
        "orthographic", "perspective", 0};
    return ANARI_CAMERA_subtypes;
  }
  case ANARI_GEOMETRY: {
    static const char *ANARI_GEOMETRY_subtypes[] = {"cone",
        "curve",
        "cylinder",
        "isosurface",
        "quad",
        "sphere",
        "triangle",
        0};
    return ANARI_GEOMETRY_subtypes;
  }
  case ANARI_MATERIAL: {
    static const char *ANARI_MATERIAL_subtypes[] = {
        "matte", "physicallyBased", 0};
    return ANARI_MATERIAL_subtypes;
  }
  case ANARI_SAMPLER: {
    static const char *ANARI_SAMPLER_subtypes[] = {"image1D", "image2D", 0};
    return ANARI_SAMPLER_subtypes;
  }
  case ANARI_SPATIAL_FIELD: {
    static const char *ANARI_SPATIAL_FIELD_subtypes[] = {
        "structuredRegular", 0};
    return ANARI_SPATIAL_FIELD_subtypes;
  }
  case ANARI_VOLUME: {
    static const char *ANARI_VOLUME_subtypes[] = {"transferFunction1D", 0};
    return ANARI_VOLUME_subtypes;
  }
  default: {
    static const char *none_subtypes[] = {0};
    return none_subtypes;
  }
  }
}
static const void *ANARI_DEVICE_allowInvalidMaterials_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "show surfaces with invalid materials";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_invalidMaterialColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          1.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "color to identify surfaces with invalid materials";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_statusCallback_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "callback used to report information to the application";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_statusCallbackUserData_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "optional pointer passed as the first argument of the status callback";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 0:
    return ANARI_DEVICE_allowInvalidMaterials_info(
        paramType, infoName, infoType);
  case 48:
    return ANARI_DEVICE_invalidMaterialColor_info(
        paramType, infoName, infoType);
  case 65:
    return ANARI_DEVICE_name_info(paramType, infoName, infoType);
  case 99:
    return ANARI_DEVICE_statusCallback_info(paramType, infoName, infoType);
  case 100:
    return ANARI_DEVICE_statusCallbackUserData_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_irradiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "amount of light in W/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "emission direction of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_angularDiameter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "apparent size of the light in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_radiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_LIGHT_directional_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_directional_color_info(paramType, infoName, infoType);
  case 53:
    return ANARI_LIGHT_directional_irradiance_info(
        paramType, infoName, infoType);
  case 28:
    return ANARI_LIGHT_directional_direction_info(
        paramType, infoName, infoType);
  case 5:
    return ANARI_LIGHT_directional_angularDiameter_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_LIGHT_directional_radiance_info(paramType, infoName, infoType);
  case 119:
    return ANARI_LIGHT_directional_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "radius of the sphere light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_radiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_LIGHT_point_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_point_color_info(paramType, infoName, infoType);
  case 75:
    return ANARI_LIGHT_point_position_info(paramType, infoName, infoType);
  case 46:
    return ANARI_LIGHT_point_intensity_info(paramType, infoName, infoType);
  case 76:
    return ANARI_LIGHT_point_power_info(paramType, infoName, infoType);
  case 86:
    return ANARI_LIGHT_point_radius_info(paramType, infoName, infoType);
  case 85:
    return ANARI_LIGHT_point_radiance_info(paramType, infoName, infoType);
  case 119:
    return ANARI_LIGHT_point_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "the axis the ring is pointing at";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_openingAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {3.141593f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opening angle in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_falloffAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.100000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "falloff angle in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "outer radius of the ring";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_innerRadius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "inner radius of the ring";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_radiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_intensityDistribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "luminous intensity distribution for photometric lights";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_c0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "direction of the C0-(half)plane";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_LIGHT_ring_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_ring_color_info(paramType, infoName, infoType);
  case 75:
    return ANARI_LIGHT_ring_position_info(paramType, infoName, infoType);
  case 28:
    return ANARI_LIGHT_ring_direction_info(paramType, infoName, infoType);
  case 70:
    return ANARI_LIGHT_ring_openingAngle_info(paramType, infoName, infoType);
  case 32:
    return ANARI_LIGHT_ring_falloffAngle_info(paramType, infoName, infoType);
  case 46:
    return ANARI_LIGHT_ring_intensity_info(paramType, infoName, infoType);
  case 76:
    return ANARI_LIGHT_ring_power_info(paramType, infoName, infoType);
  case 86:
    return ANARI_LIGHT_ring_radius_info(paramType, infoName, infoType);
  case 44:
    return ANARI_LIGHT_ring_innerRadius_info(paramType, infoName, infoType);
  case 85:
    return ANARI_LIGHT_ring_radiance_info(paramType, infoName, infoType);
  case 47:
    return ANARI_LIGHT_ring_intensityDistribution_info(
        paramType, infoName, infoType);
  case 18:
    return ANARI_LIGHT_ring_c0_info(paramType, infoName, infoType);
  case 119:
    return ANARI_LIGHT_ring_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_edge1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "vector";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vector of the first edge";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_edge2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "vector";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vector of the second edge";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_radiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_side_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "front";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "light emitting sides of the quad";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"front", "back", "both", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_intensityDistribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "luminous intensity distribution for photometric lights";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_LIGHT_quad_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_quad_color_info(paramType, infoName, infoType);
  case 75:
    return ANARI_LIGHT_quad_position_info(paramType, infoName, infoType);
  case 29:
    return ANARI_LIGHT_quad_edge1_info(paramType, infoName, infoType);
  case 30:
    return ANARI_LIGHT_quad_edge2_info(paramType, infoName, infoType);
  case 46:
    return ANARI_LIGHT_quad_intensity_info(paramType, infoName, infoType);
  case 76:
    return ANARI_LIGHT_quad_power_info(paramType, infoName, infoType);
  case 85:
    return ANARI_LIGHT_quad_radiance_info(paramType, infoName, infoType);
  case 94:
    return ANARI_LIGHT_quad_side_info(paramType, infoName, infoType);
  case 47:
    return ANARI_LIGHT_quad_intensityDistribution_info(
        paramType, infoName, infoType);
  case 119:
    return ANARI_LIGHT_quad_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_up_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "up direction of the light in world space";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_radiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_layout_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "equirectangular";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "radiance image layout";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"equirectangular", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_scale_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "scale factor for radiance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_LIGHT_hdri_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_hdri_color_info(paramType, infoName, infoType);
  case 105:
    return ANARI_LIGHT_hdri_up_info(paramType, infoName, infoType);
  case 85:
    return ANARI_LIGHT_hdri_radiance_info(paramType, infoName, infoType);
  case 55:
    return ANARI_LIGHT_hdri_layout_info(paramType, infoName, infoType);
  case 90:
    return ANARI_LIGHT_hdri_scale_info(paramType, infoName, infoType);
  case 119:
    return ANARI_LIGHT_hdri_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_lightSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(-1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of random light samples per path vertex, per default all light sources are sampled";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_roulettePathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(5)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "ray recursion depth at which to start Russian roulette termination";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxScatteringEvents_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum number of non-specular (i.e., diffuse and glossy) bounces";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "samples are clamped to this value before they are accumulated into the framebuffer";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_backgroundRefraction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "allow for alpha blending even if background is seen through refractive objects like glass";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 74:
    return ANARI_RENDERER_default_pixelSamples_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_RENDERER_default_maxPathLength_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_RENDERER_default_minContribution_info(
        paramType, infoName, infoType);
  case 108:
    return ANARI_RENDERER_default_varianceThreshold_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_default_background_info(
        paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_default_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_default_ambientRadiance_info(
        paramType, infoName, infoType);
  case 57:
    return ANARI_RENDERER_default_lightSamples_info(
        paramType, infoName, infoType);
  case 89:
    return ANARI_RENDERER_default_roulettePathLength_info(
        paramType, infoName, infoType);
  case 61:
    return ANARI_RENDERER_default_maxScatteringEvents_info(
        paramType, infoName, infoType);
  case 59:
    return ANARI_RENDERER_default_maxContribution_info(
        paramType, infoName, infoType);
  case 16:
    return ANARI_RENDERER_default_backgroundRefraction_info(
        paramType, infoName, infoType);
  case 65:
    return ANARI_RENDERER_default_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_lightSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(-1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of random light samples per path vertex, per default all light sources are sampled";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_roulettePathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(5)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "ray recursion depth at which to start Russian roulette termination";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxScatteringEvents_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum number of non-specular (i.e., diffuse and glossy) bounces";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "samples are clamped to this value before they are accumulated into the framebuffer";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_backgroundRefraction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "allow for alpha blending even if background is seen through refractive objects like glass";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 74:
    return ANARI_RENDERER_pathtracer_pixelSamples_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_RENDERER_pathtracer_maxPathLength_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_RENDERER_pathtracer_minContribution_info(
        paramType, infoName, infoType);
  case 108:
    return ANARI_RENDERER_pathtracer_varianceThreshold_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_pathtracer_background_info(
        paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_pathtracer_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_pathtracer_ambientRadiance_info(
        paramType, infoName, infoType);
  case 57:
    return ANARI_RENDERER_pathtracer_lightSamples_info(
        paramType, infoName, infoType);
  case 89:
    return ANARI_RENDERER_pathtracer_roulettePathLength_info(
        paramType, infoName, infoType);
  case 61:
    return ANARI_RENDERER_pathtracer_maxScatteringEvents_info(
        paramType, infoName, infoType);
  case 59:
    return ANARI_RENDERER_pathtracer_maxContribution_info(
        paramType, infoName, infoType);
  case 16:
    return ANARI_RENDERER_pathtracer_backgroundRefraction_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_shadows_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "whether to compute (hard) shadows";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_aoSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of rays per sample to compute ambient occlusion";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_aoDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum distance to consider for ambient occlusion";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_volumeSamplingRate_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sampling rate for volumes";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_visibleLights_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "whether light sources are potentially visible (as in the path tracer, regarding each light's visible)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 74:
    return ANARI_RENDERER_scivis_pixelSamples_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_RENDERER_scivis_maxPathLength_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_RENDERER_scivis_minContribution_info(
        paramType, infoName, infoType);
  case 108:
    return ANARI_RENDERER_scivis_varianceThreshold_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_scivis_background_info(paramType, infoName, infoType);
  case 91:
    return ANARI_RENDERER_scivis_shadows_info(paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_scivis_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_scivis_ambientRadiance_info(
        paramType, infoName, infoType);
  case 7:
    return ANARI_RENDERER_scivis_aoSamples_info(paramType, infoName, infoType);
  case 6:
    return ANARI_RENDERER_scivis_aoDistance_info(paramType, infoName, infoType);
  case 122:
    return ANARI_RENDERER_scivis_volumeSamplingRate_info(
        paramType, infoName, infoType);
  case 120:
    return ANARI_RENDERER_scivis_visibleLights_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_method_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "which debugging method to use";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"eyeLight",
          "rayDir",
          "Ng",
          "Ns",
          "color",
          "texCoord",
          "backfacing_Ng",
          "backfacing_Ns",
          "dPds",
          "dPdt",
          "primID",
          "geomID",
          "instID",
          "volume",
          "rayDir",
          "testFrame",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 63:
    return ANARI_RENDERER_debug_method_info(paramType, infoName, infoType);
  case 74:
    return ANARI_RENDERER_debug_pixelSamples_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_RENDERER_debug_maxPathLength_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_RENDERER_debug_minContribution_info(
        paramType, infoName, infoType);
  case 108:
    return ANARI_RENDERER_debug_varianceThreshold_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_debug_background_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_ARRAY1D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_ARRAY2D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_ARRAY3D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_world_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "world to be rendererd";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_renderer_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "renderer which renders the frame";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_camera_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera used to render the world";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_size_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "size of the frame in pixels (width, height)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_channel_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "enables mapping the color channel as the type specified";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_channel_depth_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "enables mapping the color channel as the type specified";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_FRAME_name_info(paramType, infoName, infoType);
  case 123:
    return ANARI_FRAME_world_info(paramType, infoName, infoType);
  case 87:
    return ANARI_FRAME_renderer_info(paramType, infoName, infoType);
  case 19:
    return ANARI_FRAME_camera_info(paramType, infoName, infoType);
  case 95:
    return ANARI_FRAME_size_info(paramType, infoName, infoType);
  case 21:
    return ANARI_FRAME_channel_color_info(paramType, infoName, infoType);
  case 22:
    return ANARI_FRAME_channel_depth_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_surface_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of surface objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_volume_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of volume objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_VOLUME, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_light_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of light objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_GROUP_name_info(paramType, infoName, infoType);
  case 101:
    return ANARI_GROUP_surface_info(paramType, infoName, infoType);
  case 121:
    return ANARI_GROUP_volume_info(paramType, infoName, infoType);
  case 56:
    return ANARI_GROUP_light_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_instance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of instance objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_INSTANCE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_surface_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced surface objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_volume_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced volume objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_light_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced light objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_WORLD_name_info(paramType, infoName, infoType);
  case 45:
    return ANARI_WORLD_instance_info(paramType, infoName, infoType);
  case 101:
    return ANARI_WORLD_surface_info(paramType, infoName, infoType);
  case 121:
    return ANARI_WORLD_volume_info(paramType, infoName, infoType);
  case 56:
    return ANARI_WORLD_light_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_geometry_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "geometry object defining the surface geometry";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_material_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "material object defining the surface appearance";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_SURFACE_name_info(paramType, infoName, infoType);
  case 37:
    return ANARI_SURFACE_geometry_info(paramType, infoName, infoType);
  case 58:
    return ANARI_SURFACE_material_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera position";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "main viewing direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_up_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera up direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_imageRegion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "region mapped to the frame";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_aspect_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "aspect ratio";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_height_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "height of image plane";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_near_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "near plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_far_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "far plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_CAMERA_orthographic_name_info(paramType, infoName, infoType);
  case 75:
    return ANARI_CAMERA_orthographic_position_info(
        paramType, infoName, infoType);
  case 28:
    return ANARI_CAMERA_orthographic_direction_info(
        paramType, infoName, infoType);
  case 105:
    return ANARI_CAMERA_orthographic_up_info(paramType, infoName, infoType);
  case 40:
    return ANARI_CAMERA_orthographic_imageRegion_info(
        paramType, infoName, infoType);
  case 8:
    return ANARI_CAMERA_orthographic_aspect_info(paramType, infoName, infoType);
  case 38:
    return ANARI_CAMERA_orthographic_height_info(paramType, infoName, infoType);
  case 66:
    return ANARI_CAMERA_orthographic_near_info(paramType, infoName, infoType);
  case 33:
    return ANARI_CAMERA_orthographic_far_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera position";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "main viewing direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_up_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera up direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_imageRegion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "region mapped to the frame";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_fovy_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.047198f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertical field of view in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_aspect_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "aspect ratio";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_near_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "near plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_far_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "far plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_CAMERA_perspective_name_info(paramType, infoName, infoType);
  case 75:
    return ANARI_CAMERA_perspective_position_info(
        paramType, infoName, infoType);
  case 28:
    return ANARI_CAMERA_perspective_direction_info(
        paramType, infoName, infoType);
  case 105:
    return ANARI_CAMERA_perspective_up_info(paramType, infoName, infoType);
  case 40:
    return ANARI_CAMERA_perspective_imageRegion_info(
        paramType, infoName, infoType);
  case 36:
    return ANARI_CAMERA_perspective_fovy_info(paramType, infoName, infoType);
  case 8:
    return ANARI_CAMERA_perspective_aspect_info(paramType, infoName, infoType);
  case 66:
    return ANARI_CAMERA_perspective_near_info(paramType, infoName, infoType);
  case 33:
    return ANARI_CAMERA_perspective_far_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_cap_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex cap type";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_caps_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "none";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cap type";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "none", "first", "second", "both", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_GEOMETRY_cone_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_cone_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_cone_attribute0_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_cone_attribute1_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_cone_attribute2_info(paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_cone_attribute3_info(paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_cone_primitive_color_info(
        paramType, infoName, infoType);
  case 77:
    return ANARI_GEOMETRY_cone_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 78:
    return ANARI_GEOMETRY_cone_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_GEOMETRY_cone_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_cone_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_cone_primitive_id_info(paramType, infoName, infoType);
  case 116:
    return ANARI_GEOMETRY_cone_vertex_position_info(
        paramType, infoName, infoType);
  case 117:
    return ANARI_GEOMETRY_cone_vertex_radius_info(
        paramType, infoName, infoType);
  case 113:
    return ANARI_GEOMETRY_cone_vertex_cap_info(paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_cone_vertex_color_info(paramType, infoName, infoType);
  case 109:
    return ANARI_GEOMETRY_cone_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 110:
    return ANARI_GEOMETRY_cone_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 111:
    return ANARI_GEOMETRY_cone_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_cone_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_cone_primitive_index_info(
        paramType, infoName, infoType);
  case 20:
    return ANARI_GEOMETRY_cone_caps_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global radius";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_GEOMETRY_curve_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_curve_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_curve_attribute0_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_curve_attribute1_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_curve_attribute2_info(paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_curve_attribute3_info(paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_curve_primitive_color_info(
        paramType, infoName, infoType);
  case 77:
    return ANARI_GEOMETRY_curve_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 78:
    return ANARI_GEOMETRY_curve_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_GEOMETRY_curve_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_curve_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_curve_primitive_id_info(
        paramType, infoName, infoType);
  case 116:
    return ANARI_GEOMETRY_curve_vertex_position_info(
        paramType, infoName, infoType);
  case 117:
    return ANARI_GEOMETRY_curve_vertex_radius_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_curve_vertex_color_info(
        paramType, infoName, infoType);
  case 109:
    return ANARI_GEOMETRY_curve_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 110:
    return ANARI_GEOMETRY_curve_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 111:
    return ANARI_GEOMETRY_curve_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_curve_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_curve_primitive_index_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_curve_radius_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_cap_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cylinder cap type";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cylinder radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cylinder radius";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_caps_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "none";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cylinder cap type";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "none", "first", "second", "both", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_GEOMETRY_cylinder_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_cylinder_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_cylinder_attribute0_info(
        paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_cylinder_attribute1_info(
        paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_cylinder_attribute2_info(
        paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_cylinder_attribute3_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_cylinder_primitive_color_info(
        paramType, infoName, infoType);
  case 77:
    return ANARI_GEOMETRY_cylinder_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 78:
    return ANARI_GEOMETRY_cylinder_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_GEOMETRY_cylinder_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_cylinder_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_cylinder_primitive_id_info(
        paramType, infoName, infoType);
  case 116:
    return ANARI_GEOMETRY_cylinder_vertex_position_info(
        paramType, infoName, infoType);
  case 113:
    return ANARI_GEOMETRY_cylinder_vertex_cap_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_cylinder_vertex_color_info(
        paramType, infoName, infoType);
  case 109:
    return ANARI_GEOMETRY_cylinder_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 110:
    return ANARI_GEOMETRY_cylinder_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 111:
    return ANARI_GEOMETRY_cylinder_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_cylinder_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_cylinder_primitive_index_info(
        paramType, infoName, infoType);
  case 84:
    return ANARI_GEOMETRY_cylinder_primitive_radius_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_cylinder_radius_info(paramType, infoName, infoType);
  case 20:
    return ANARI_GEOMETRY_cylinder_caps_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_isovalue_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "isovalue(s) defining the isosurface(s)";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_field_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "spatial field to be isosurfaced";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_GEOMETRY_isosurface_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_isosurface_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_isosurface_attribute0_info(
        paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_isosurface_attribute1_info(
        paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_isosurface_attribute2_info(
        paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_isosurface_attribute3_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_isosurface_primitive_color_info(
        paramType, infoName, infoType);
  case 77:
    return ANARI_GEOMETRY_isosurface_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 78:
    return ANARI_GEOMETRY_isosurface_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_GEOMETRY_isosurface_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_isosurface_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_isosurface_primitive_id_info(
        paramType, infoName, infoType);
  case 54:
    return ANARI_GEOMETRY_isosurface_isovalue_info(
        paramType, infoName, infoType);
  case 34:
    return ANARI_GEOMETRY_isosurface_field_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_tangent_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3,
          ANARI_FIXED16_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_FIXED16_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC4, ANARI_UINT64_VEC4, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_GEOMETRY_quad_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_quad_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_quad_attribute0_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_quad_attribute1_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_quad_attribute2_info(paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_quad_attribute3_info(paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_quad_primitive_color_info(
        paramType, infoName, infoType);
  case 77:
    return ANARI_GEOMETRY_quad_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 78:
    return ANARI_GEOMETRY_quad_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_GEOMETRY_quad_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_quad_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_quad_primitive_id_info(paramType, infoName, infoType);
  case 116:
    return ANARI_GEOMETRY_quad_vertex_position_info(
        paramType, infoName, infoType);
  case 115:
    return ANARI_GEOMETRY_quad_vertex_normal_info(
        paramType, infoName, infoType);
  case 118:
    return ANARI_GEOMETRY_quad_vertex_tangent_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_quad_vertex_color_info(paramType, infoName, infoType);
  case 109:
    return ANARI_GEOMETRY_quad_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 110:
    return ANARI_GEOMETRY_quad_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 111:
    return ANARI_GEOMETRY_quad_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_quad_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_quad_primitive_index_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sphere position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sphere radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global sphere radius";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_GEOMETRY_sphere_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_sphere_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_sphere_attribute0_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_sphere_attribute1_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_sphere_attribute2_info(paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_sphere_attribute3_info(paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_sphere_primitive_color_info(
        paramType, infoName, infoType);
  case 77:
    return ANARI_GEOMETRY_sphere_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 78:
    return ANARI_GEOMETRY_sphere_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_GEOMETRY_sphere_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_sphere_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_sphere_primitive_id_info(
        paramType, infoName, infoType);
  case 116:
    return ANARI_GEOMETRY_sphere_vertex_position_info(
        paramType, infoName, infoType);
  case 117:
    return ANARI_GEOMETRY_sphere_vertex_radius_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_sphere_vertex_color_info(
        paramType, infoName, infoType);
  case 109:
    return ANARI_GEOMETRY_sphere_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 110:
    return ANARI_GEOMETRY_sphere_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 111:
    return ANARI_GEOMETRY_sphere_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_sphere_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_sphere_primitive_index_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_sphere_radius_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_tangent_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3,
          ANARI_FIXED16_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_FIXED16_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC3, ANARI_UINT64_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_GEOMETRY_triangle_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_triangle_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_triangle_attribute0_info(
        paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_triangle_attribute1_info(
        paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_triangle_attribute2_info(
        paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_triangle_attribute3_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_triangle_primitive_color_info(
        paramType, infoName, infoType);
  case 77:
    return ANARI_GEOMETRY_triangle_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 78:
    return ANARI_GEOMETRY_triangle_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 79:
    return ANARI_GEOMETRY_triangle_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_triangle_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_triangle_primitive_id_info(
        paramType, infoName, infoType);
  case 116:
    return ANARI_GEOMETRY_triangle_vertex_position_info(
        paramType, infoName, infoType);
  case 115:
    return ANARI_GEOMETRY_triangle_vertex_normal_info(
        paramType, infoName, infoType);
  case 118:
    return ANARI_GEOMETRY_triangle_vertex_tangent_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_triangle_vertex_color_info(
        paramType, infoName, infoType);
  case 109:
    return ANARI_GEOMETRY_triangle_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 110:
    return ANARI_GEOMETRY_triangle_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 111:
    return ANARI_GEOMETRY_triangle_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_triangle_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_triangle_primitive_index_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "the axis of the spot";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_openingAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {3.141593f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opening angle in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_falloffAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.100000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "falloff angle in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_LIGHT_spot_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_spot_color_info(paramType, infoName, infoType);
  case 75:
    return ANARI_LIGHT_spot_position_info(paramType, infoName, infoType);
  case 28:
    return ANARI_LIGHT_spot_direction_info(paramType, infoName, infoType);
  case 70:
    return ANARI_LIGHT_spot_openingAngle_info(paramType, infoName, infoType);
  case 32:
    return ANARI_LIGHT_spot_falloffAngle_info(paramType, infoName, infoType);
  case 46:
    return ANARI_LIGHT_spot_intensity_info(paramType, infoName, infoType);
  case 76:
    return ANARI_LIGHT_spot_power_info(paramType, infoName, infoType);
  case 119:
    return ANARI_LIGHT_spot_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.800000f, 0.800000f, 0.800000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "diffuse color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opacity";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_alphaMode_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "opaque";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "alpha mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"opaque", "blend", "mask", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_alphaCutoff_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cutoff for alpha mask mode";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_MATERIAL_matte_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_MATERIAL_matte_color_info(paramType, infoName, infoType);
  case 69:
    return ANARI_MATERIAL_matte_opacity_info(paramType, infoName, infoType);
  case 2:
    return ANARI_MATERIAL_matte_alphaMode_info(paramType, infoName, infoType);
  case 1:
    return ANARI_MATERIAL_matte_alphaCutoff_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_baseColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "base color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opacity";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_metallic_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "metallic factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_roughness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "roughness factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "normal map";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_emissive_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "emissive factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_occlusion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "precomputed occlusion";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_alphaMode_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "opaque";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "alpha mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"opaque", "blend", "mask", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_alphaCutoff_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cutoff for alpha mask mode";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_specular_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "specular factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_specularColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "specular color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_clearcoat_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "clearcoat factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_clearcoatRoughness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "clearcoat roughness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_clearcoatNormal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "clearcoat normal map";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_transmission_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transmission factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_ior_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index of refraction";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_thickness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wall thickness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_attenuationDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {INFINITY};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "attenuation distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_attenuationColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "attenuation color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_sheenColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sheen color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_sheenRoughness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sheen roughness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_iridescence_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "iridescence factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_iridescenceIor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.300000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "iridescence index of refraction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_iridescenceThickness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "iridescence thicknness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_MATERIAL_physicallyBased_name_info(
        paramType, infoName, infoType);
  case 17:
    return ANARI_MATERIAL_physicallyBased_baseColor_info(
        paramType, infoName, infoType);
  case 69:
    return ANARI_MATERIAL_physicallyBased_opacity_info(
        paramType, infoName, infoType);
  case 62:
    return ANARI_MATERIAL_physicallyBased_metallic_info(
        paramType, infoName, infoType);
  case 88:
    return ANARI_MATERIAL_physicallyBased_roughness_info(
        paramType, infoName, infoType);
  case 67:
    return ANARI_MATERIAL_physicallyBased_normal_info(
        paramType, infoName, infoType);
  case 31:
    return ANARI_MATERIAL_physicallyBased_emissive_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_MATERIAL_physicallyBased_occlusion_info(
        paramType, infoName, infoType);
  case 2:
    return ANARI_MATERIAL_physicallyBased_alphaMode_info(
        paramType, infoName, infoType);
  case 1:
    return ANARI_MATERIAL_physicallyBased_alphaCutoff_info(
        paramType, infoName, infoType);
  case 97:
    return ANARI_MATERIAL_physicallyBased_specular_info(
        paramType, infoName, infoType);
  case 98:
    return ANARI_MATERIAL_physicallyBased_specularColor_info(
        paramType, infoName, infoType);
  case 23:
    return ANARI_MATERIAL_physicallyBased_clearcoat_info(
        paramType, infoName, infoType);
  case 25:
    return ANARI_MATERIAL_physicallyBased_clearcoatRoughness_info(
        paramType, infoName, infoType);
  case 24:
    return ANARI_MATERIAL_physicallyBased_clearcoatNormal_info(
        paramType, infoName, infoType);
  case 103:
    return ANARI_MATERIAL_physicallyBased_transmission_info(
        paramType, infoName, infoType);
  case 49:
    return ANARI_MATERIAL_physicallyBased_ior_info(
        paramType, infoName, infoType);
  case 102:
    return ANARI_MATERIAL_physicallyBased_thickness_info(
        paramType, infoName, infoType);
  case 10:
    return ANARI_MATERIAL_physicallyBased_attenuationDistance_info(
        paramType, infoName, infoType);
  case 9:
    return ANARI_MATERIAL_physicallyBased_attenuationColor_info(
        paramType, infoName, infoType);
  case 92:
    return ANARI_MATERIAL_physicallyBased_sheenColor_info(
        paramType, infoName, infoType);
  case 93:
    return ANARI_MATERIAL_physicallyBased_sheenRoughness_info(
        paramType, infoName, infoType);
  case 50:
    return ANARI_MATERIAL_physicallyBased_iridescence_info(
        paramType, infoName, infoType);
  case 51:
    return ANARI_MATERIAL_physicallyBased_iridescenceIor_info(
        paramType, infoName, infoType);
  case 52:
    return ANARI_MATERIAL_physicallyBased_iridescenceThickness_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_image_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array backing the sampler";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inAttribute_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "attribute0";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "input surface attribute (texture coordinate)";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "nearest";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_wrapMode1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 1st dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "transform applied to the input attribute before sampling";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output inTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_outTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transform applied to the sampled values";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_outOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output outTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_SAMPLER_image1D_name_info(paramType, infoName, infoType);
  case 39:
    return ANARI_SAMPLER_image1D_image_info(paramType, infoName, infoType);
  case 41:
    return ANARI_SAMPLER_image1D_inAttribute_info(
        paramType, infoName, infoType);
  case 35:
    return ANARI_SAMPLER_image1D_filter_info(paramType, infoName, infoType);
  case 124:
    return ANARI_SAMPLER_image1D_wrapMode1_info(paramType, infoName, infoType);
  case 43:
    return ANARI_SAMPLER_image1D_inTransform_info(
        paramType, infoName, infoType);
  case 42:
    return ANARI_SAMPLER_image1D_inOffset_info(paramType, infoName, infoType);
  case 73:
    return ANARI_SAMPLER_image1D_outTransform_info(
        paramType, infoName, infoType);
  case 72:
    return ANARI_SAMPLER_image1D_outOffset_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_image_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array backing the sampler";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inAttribute_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "attribute0";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "input surface attribute (texture coordinate)";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "nearest";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_wrapMode1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 1st dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_wrapMode2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 2nd dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "transform applied to the input attribute before sampling";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output inTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_outTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transform applied to the sampled values";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_outOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output outTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_SAMPLER_image2D_name_info(paramType, infoName, infoType);
  case 39:
    return ANARI_SAMPLER_image2D_image_info(paramType, infoName, infoType);
  case 41:
    return ANARI_SAMPLER_image2D_inAttribute_info(
        paramType, infoName, infoType);
  case 35:
    return ANARI_SAMPLER_image2D_filter_info(paramType, infoName, infoType);
  case 124:
    return ANARI_SAMPLER_image2D_wrapMode1_info(paramType, infoName, infoType);
  case 125:
    return ANARI_SAMPLER_image2D_wrapMode2_info(paramType, infoName, infoType);
  case 43:
    return ANARI_SAMPLER_image2D_inTransform_info(
        paramType, infoName, infoType);
  case 42:
    return ANARI_SAMPLER_image2D_inOffset_info(paramType, infoName, infoType);
  case 73:
    return ANARI_SAMPLER_image2D_outTransform_info(
        paramType, infoName, infoType);
  case 72:
    return ANARI_SAMPLER_image2D_outOffset_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 24;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_data_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of vertex centered scalar values";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8,
          ANARI_INT16,
          ANARI_UINT16,
          ANARI_FLOAT32,
          ANARI_FLOAT64,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 24;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_origin_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "origin of the grid in object-space";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 24;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "size of the grid cells in object-space";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 24;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "linear";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode used to interpolate the grid";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 24;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_SPATIAL_FIELD_structuredRegular_name_info(
        paramType, infoName, infoType);
  case 27:
    return ANARI_SPATIAL_FIELD_structuredRegular_data_info(
        paramType, infoName, infoType);
  case 71:
    return ANARI_SPATIAL_FIELD_structuredRegular_origin_info(
        paramType, infoName, infoType);
  case 96:
    return ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(
        paramType, infoName, infoType);
  case 35:
    return ANARI_SPATIAL_FIELD_structuredRegular_filter_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_value_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "spatial field used for the field values of the volume";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_valueRange_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
      static const float default_value[2] = {0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sampled values of field are clamped to this range";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sampled color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sampled opacity";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_unitDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "makes volumes uniformly thinner or thicker";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 65:
    return ANARI_VOLUME_transferFunction1D_name_info(
        paramType, infoName, infoType);
  case 106:
    return ANARI_VOLUME_transferFunction1D_value_info(
        paramType, infoName, infoType);
  case 107:
    return ANARI_VOLUME_transferFunction1D_valueRange_info(
        paramType, infoName, infoType);
  case 26:
    return ANARI_VOLUME_transferFunction1D_color_info(
        paramType, infoName, infoType);
  case 69:
    return ANARI_VOLUME_transferFunction1D_opacity_info(
        paramType, infoName, infoType);
  case 104:
    return ANARI_VOLUME_transferFunction1D_unitDistance_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 11:
    return ANARI_CAMERA_orthographic_param_info(
        paramName, paramType, infoName, infoType);
  case 13:
    return ANARI_CAMERA_perspective_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 0:
    return ANARI_GEOMETRY_cone_param_info(
        paramName, paramType, infoName, infoType);
  case 1:
    return ANARI_GEOMETRY_curve_param_info(
        paramName, paramType, infoName, infoType);
  case 2:
    return ANARI_GEOMETRY_cylinder_param_info(
        paramName, paramType, infoName, infoType);
  case 9:
    return ANARI_GEOMETRY_isosurface_param_info(
        paramName, paramType, infoName, infoType);
  case 16:
    return ANARI_GEOMETRY_quad_param_info(
        paramName, paramType, infoName, infoType);
  case 19:
    return ANARI_GEOMETRY_sphere_param_info(
        paramName, paramType, infoName, infoType);
  case 23:
    return ANARI_GEOMETRY_triangle_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 5:
    return ANARI_LIGHT_directional_param_info(
        paramName, paramType, infoName, infoType);
  case 15:
    return ANARI_LIGHT_point_param_info(
        paramName, paramType, infoName, infoType);
  case 17:
    return ANARI_LIGHT_ring_param_info(
        paramName, paramType, infoName, infoType);
  case 16:
    return ANARI_LIGHT_quad_param_info(
        paramName, paramType, infoName, infoType);
  case 6:
    return ANARI_LIGHT_hdri_param_info(
        paramName, paramType, infoName, infoType);
  case 20:
    return ANARI_LIGHT_spot_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 10:
    return ANARI_MATERIAL_matte_param_info(
        paramName, paramType, infoName, infoType);
  case 14:
    return ANARI_MATERIAL_physicallyBased_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 4:
    return ANARI_RENDERER_default_param_info(
        paramName, paramType, infoName, infoType);
  case 12:
    return ANARI_RENDERER_pathtracer_param_info(
        paramName, paramType, infoName, infoType);
  case 18:
    return ANARI_RENDERER_scivis_param_info(
        paramName, paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_debug_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 7:
    return ANARI_SAMPLER_image1D_param_info(
        paramName, paramType, infoName, infoType);
  case 8:
    return ANARI_SAMPLER_image2D_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 21:
    return ANARI_SPATIAL_FIELD_structuredRegular_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 22:
    return ANARI_VOLUME_transferFunction1D_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_param_info_enum(ANARIDataType type,
    const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (type) {
  case ANARI_CAMERA:
    return ANARI_CAMERA_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_GEOMETRY:
    return ANARI_GEOMETRY_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_LIGHT:
    return ANARI_LIGHT_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_MATERIAL:
    return ANARI_MATERIAL_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_RENDERER:
    return ANARI_RENDERER_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_SAMPLER:
    return ANARI_SAMPLER_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_SPATIAL_FIELD:
    return ANARI_SPATIAL_FIELD_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_VOLUME:
    return ANARI_VOLUME_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_DEVICE:
    return ANARI_DEVICE_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY1D:
    return ANARI_ARRAY1D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY2D:
    return ANARI_ARRAY2D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY3D:
    return ANARI_ARRAY3D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_FRAME:
    return ANARI_FRAME_param_info(paramName, paramType, infoName, infoType);
  case ANARI_GROUP:
    return ANARI_GROUP_param_info(paramName, paramType, infoName, infoType);
  case ANARI_WORLD:
    return ANARI_WORLD_param_info(paramName, paramType, infoName, infoType);
  case ANARI_SURFACE:
    return ANARI_SURFACE_param_info(paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_param_info(ANARIDataType type,
    const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    const char *infoNameString,
    ANARIDataType infoType)
{
  int infoName = info_hash(infoNameString);
  return query_param_info_enum(
      type, subtype, paramName, paramType, infoName, infoType);
}
static const void *ANARI_DEVICE_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "device object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"allowInvalidMaterials", ANARI_BOOL},
          {"invalidMaterialColor", ANARI_FLOAT32_VEC4},
          {"name", ANARI_STRING},
          {"statusCallback", ANARI_STATUS_CALLBACK},
          {"statusCallbackUserData", ANARI_VOID_POINTER},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_RING",
          "ANARI_KHR_LIGHT_QUAD",
          "ANARI_KHR_LIGHT_HDRI",
          "ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_ISOSURFACE",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_AREA_LIGHTS",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "directional light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"irradiance", ANARI_FLOAT32},
          {"direction", ANARI_FLOAT32_VEC3},
          {"angularDiameter", ANARI_FLOAT32},
          {"radiance", ANARI_FLOAT32},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 0;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "point light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {"radius", ANARI_FLOAT32},
          {"radiance", ANARI_FLOAT32},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 1;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "ring light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"openingAngle", ANARI_FLOAT32},
          {"falloffAngle", ANARI_FLOAT32},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {"radius", ANARI_FLOAT32},
          {"innerRadius", ANARI_FLOAT32},
          {"radiance", ANARI_FLOAT32},
          {"intensityDistribution", ANARI_ARRAY1D},
          {"intensityDistribution", ANARI_ARRAY2D},
          {"c0", ANARI_FLOAT32_VEC3},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 2;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "quad light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"edge1", ANARI_FLOAT32_VEC3},
          {"edge2", ANARI_FLOAT32_VEC3},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {"radiance", ANARI_FLOAT32},
          {"side", ANARI_STRING},
          {"intensityDistribution", ANARI_ARRAY1D},
          {"intensityDistribution", ANARI_ARRAY2D},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 3;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "hdri light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"up", ANARI_FLOAT32_VEC3},
          {"radiance", ANARI_ARRAY2D},
          {"layout", ANARI_STRING},
          {"scale", ANARI_FLOAT32},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 4;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The path tracer supports soft shadows, indirect illumination and realistic materials.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"lightSamples", ANARI_INT32},
          {"roulettePathLength", ANARI_INT32},
          {"maxScatteringEvents", ANARI_INT32},
          {"maxContribution", ANARI_FLOAT32},
          {"backgroundRefraction", ANARI_BOOL},
          {"name", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 5;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_RING",
          "ANARI_KHR_LIGHT_QUAD",
          "ANARI_KHR_LIGHT_HDRI",
          "ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_ISOSURFACE",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_AREA_LIGHTS",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The path tracer supports soft shadows, indirect illumination and realistic materials.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"lightSamples", ANARI_INT32},
          {"roulettePathLength", ANARI_INT32},
          {"maxScatteringEvents", ANARI_INT32},
          {"maxContribution", ANARI_FLOAT32},
          {"backgroundRefraction", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 6;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_RING",
          "ANARI_KHR_LIGHT_QUAD",
          "ANARI_KHR_LIGHT_HDRI",
          "ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_ISOSURFACE",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_AREA_LIGHTS",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The SciVis renderer is a fast ray tracer for scientific visualization which supports volume rendering and ambient occlusion (AO).";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"shadows", ANARI_BOOL},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"aoSamples", ANARI_INT32},
          {"aoDistance", ANARI_FLOAT32},
          {"volumeSamplingRate", ANARI_FLOAT32},
          {"visibleLights", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 7;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_RING",
          "ANARI_KHR_LIGHT_QUAD",
          "ANARI_KHR_LIGHT_HDRI",
          "ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_ISOSURFACE",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_AREA_LIGHTS",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "This renderer is used for debugging the underlying OSPRay system.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"method", ANARI_STRING},
          {"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 8;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_RING",
          "ANARI_KHR_LIGHT_QUAD",
          "ANARI_KHR_LIGHT_HDRI",
          "ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_ISOSURFACE",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_AREA_LIGHTS",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "one dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "two dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "three dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "frame object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"world", ANARI_WORLD},
          {"renderer", ANARI_RENDERER},
          {"camera", ANARI_CAMERA},
          {"size", ANARI_UINT32_VEC2},
          {"channel.color", ANARI_DATA_TYPE},
          {"channel.depth", ANARI_DATA_TYPE},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 10: // channel
    if (infoType == ANARI_STRING_LIST) {
      static const char *channel[] = {"channel.color", "channel.depth", 0};
      return channel;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "group object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"surface", ANARI_ARRAY1D},
          {"volume", ANARI_ARRAY1D},
          {"light", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "world object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"instance", ANARI_ARRAY1D},
          {"surface", ANARI_ARRAY1D},
          {"volume", ANARI_ARRAY1D},
          {"light", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "surface object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"geometry", ANARI_GEOMETRY},
          {"material", ANARI_MATERIAL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "orthographic camera object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"up", ANARI_FLOAT32_VEC3},
          {"imageRegion", ANARI_FLOAT32_BOX2},
          {"aspect", ANARI_FLOAT32},
          {"height", ANARI_FLOAT32},
          {"near", ANARI_FLOAT32},
          {"far", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 9;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "perspective camera object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"up", ANARI_FLOAT32_VEC3},
          {"imageRegion", ANARI_FLOAT32_BOX2},
          {"fovy", ANARI_FLOAT32},
          {"aspect", ANARI_FLOAT32},
          {"near", ANARI_FLOAT32},
          {"far", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 10;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "cone geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.cap", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"caps", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 11;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "curve geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 12;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "cylinder geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.cap", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"primitive.radius", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {"caps", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 13;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "isosurface geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"isovalue", ANARI_FLOAT32},
          {"isovalue", ANARI_ARRAY1D},
          {"field", ANARI_SPATIAL_FIELD},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 14;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "quad geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.normal", ANARI_ARRAY1D},
          {"vertex.tangent", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 15;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "sphere geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 16;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "triangle geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.normal", ANARI_ARRAY1D},
          {"vertex.tangent", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 17;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "spot light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"openingAngle", ANARI_FLOAT32},
          {"falloffAngle", ANARI_FLOAT32},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 18;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "matte material object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"color", ANARI_SAMPLER},
          {"color", ANARI_STRING},
          {"opacity", ANARI_FLOAT32},
          {"opacity", ANARI_SAMPLER},
          {"opacity", ANARI_STRING},
          {"alphaMode", ANARI_STRING},
          {"alphaCutoff", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 20;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "physically based material object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"baseColor", ANARI_FLOAT32_VEC3},
          {"baseColor", ANARI_SAMPLER},
          {"baseColor", ANARI_STRING},
          {"opacity", ANARI_FLOAT32},
          {"opacity", ANARI_SAMPLER},
          {"opacity", ANARI_STRING},
          {"metallic", ANARI_FLOAT32},
          {"metallic", ANARI_SAMPLER},
          {"metallic", ANARI_STRING},
          {"roughness", ANARI_FLOAT32},
          {"roughness", ANARI_SAMPLER},
          {"roughness", ANARI_STRING},
          {"normal", ANARI_SAMPLER},
          {"emissive", ANARI_FLOAT32_VEC3},
          {"emissive", ANARI_SAMPLER},
          {"emissive", ANARI_STRING},
          {"occlusion", ANARI_SAMPLER},
          {"alphaMode", ANARI_STRING},
          {"alphaCutoff", ANARI_FLOAT32},
          {"specular", ANARI_FLOAT32},
          {"specular", ANARI_SAMPLER},
          {"specular", ANARI_STRING},
          {"specularColor", ANARI_FLOAT32_VEC3},
          {"specularColor", ANARI_SAMPLER},
          {"specularColor", ANARI_STRING},
          {"clearcoat", ANARI_FLOAT32},
          {"clearcoat", ANARI_SAMPLER},
          {"clearcoat", ANARI_STRING},
          {"clearcoatRoughness", ANARI_FLOAT32},
          {"clearcoatRoughness", ANARI_SAMPLER},
          {"clearcoatRoughness", ANARI_STRING},
          {"clearcoatNormal", ANARI_SAMPLER},
          {"transmission", ANARI_FLOAT32},
          {"transmission", ANARI_SAMPLER},
          {"transmission", ANARI_STRING},
          {"ior", ANARI_FLOAT32},
          {"ior", ANARI_SAMPLER},
          {"ior", ANARI_STRING},
          {"thickness", ANARI_FLOAT32},
          {"thickness", ANARI_SAMPLER},
          {"thickness", ANARI_STRING},
          {"attenuationDistance", ANARI_FLOAT32},
          {"attenuationColor", ANARI_FLOAT32_VEC3},
          {"sheenColor", ANARI_FLOAT32_VEC3},
          {"sheenColor", ANARI_SAMPLER},
          {"sheenColor", ANARI_STRING},
          {"sheenRoughness", ANARI_FLOAT32},
          {"sheenRoughness", ANARI_SAMPLER},
          {"sheenRoughness", ANARI_STRING},
          {"iridescence", ANARI_FLOAT32},
          {"iridescence", ANARI_SAMPLER},
          {"iridescence", ANARI_STRING},
          {"iridescenceIor", ANARI_FLOAT32},
          {"iridescenceThickness", ANARI_FLOAT32},
          {"iridescenceThickness", ANARI_SAMPLER},
          {"iridescenceThickness", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 21;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "image1D object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"image", ANARI_ARRAY1D},
          {"inAttribute", ANARI_STRING},
          {"filter", ANARI_STRING},
          {"wrapMode1", ANARI_STRING},
          {"inTransform", ANARI_FLOAT32_MAT4},
          {"inOffset", ANARI_FLOAT32_VEC4},
          {"outTransform", ANARI_FLOAT32_MAT4},
          {"outOffset", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 22;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "image2D object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"image", ANARI_ARRAY2D},
          {"inAttribute", ANARI_STRING},
          {"filter", ANARI_STRING},
          {"wrapMode1", ANARI_STRING},
          {"wrapMode2", ANARI_STRING},
          {"inTransform", ANARI_FLOAT32_MAT4},
          {"inOffset", ANARI_FLOAT32_VEC4},
          {"outTransform", ANARI_FLOAT32_MAT4},
          {"outOffset", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 23;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "structured regular spatial field object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"data", ANARI_ARRAY3D},
          {"origin", ANARI_FLOAT32_VEC3},
          {"spacing", ANARI_FLOAT32_VEC3},
          {"filter", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 24;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "transferFunction1D volume object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"value", ANARI_SPATIAL_FIELD},
          {"valueRange", ANARI_FLOAT32_BOX1},
          {"valueRange", ANARI_FLOAT64_BOX1},
          {"color", ANARI_FLOAT32_VEC4},
          {"color", ANARI_FLOAT32_VEC3},
          {"color", ANARI_ARRAY1D},
          {"opacity", ANARI_FLOAT32},
          {"opacity", ANARI_ARRAY1D},
          {"unitDistance", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 25;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 11:
    return ANARI_CAMERA_orthographic_info(infoName, infoType);
  case 13:
    return ANARI_CAMERA_perspective_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 0:
    return ANARI_GEOMETRY_cone_info(infoName, infoType);
  case 1:
    return ANARI_GEOMETRY_curve_info(infoName, infoType);
  case 2:
    return ANARI_GEOMETRY_cylinder_info(infoName, infoType);
  case 9:
    return ANARI_GEOMETRY_isosurface_info(infoName, infoType);
  case 16:
    return ANARI_GEOMETRY_quad_info(infoName, infoType);
  case 19:
    return ANARI_GEOMETRY_sphere_info(infoName, infoType);
  case 23:
    return ANARI_GEOMETRY_triangle_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 5:
    return ANARI_LIGHT_directional_info(infoName, infoType);
  case 15:
    return ANARI_LIGHT_point_info(infoName, infoType);
  case 17:
    return ANARI_LIGHT_ring_info(infoName, infoType);
  case 16:
    return ANARI_LIGHT_quad_info(infoName, infoType);
  case 6:
    return ANARI_LIGHT_hdri_info(infoName, infoType);
  case 20:
    return ANARI_LIGHT_spot_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 10:
    return ANARI_MATERIAL_matte_info(infoName, infoType);
  case 14:
    return ANARI_MATERIAL_physicallyBased_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 4:
    return ANARI_RENDERER_default_info(infoName, infoType);
  case 12:
    return ANARI_RENDERER_pathtracer_info(infoName, infoType);
  case 18:
    return ANARI_RENDERER_scivis_info(infoName, infoType);
  case 3:
    return ANARI_RENDERER_debug_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 7:
    return ANARI_SAMPLER_image1D_info(infoName, infoType);
  case 8:
    return ANARI_SAMPLER_image2D_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 21:
    return ANARI_SPATIAL_FIELD_structuredRegular_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 22:
    return ANARI_VOLUME_transferFunction1D_info(infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_object_info_enum(ANARIDataType type,
    const char *subtype,
    int infoName,
    ANARIDataType infoType)
{
  switch (type) {
  case ANARI_CAMERA:
    return ANARI_CAMERA_info(subtype, infoName, infoType);
  case ANARI_GEOMETRY:
    return ANARI_GEOMETRY_info(subtype, infoName, infoType);
  case ANARI_LIGHT:
    return ANARI_LIGHT_info(subtype, infoName, infoType);
  case ANARI_MATERIAL:
    return ANARI_MATERIAL_info(subtype, infoName, infoType);
  case ANARI_RENDERER:
    return ANARI_RENDERER_info(subtype, infoName, infoType);
  case ANARI_SAMPLER:
    return ANARI_SAMPLER_info(subtype, infoName, infoType);
  case ANARI_SPATIAL_FIELD:
    return ANARI_SPATIAL_FIELD_info(subtype, infoName, infoType);
  case ANARI_VOLUME:
    return ANARI_VOLUME_info(subtype, infoName, infoType);
  case ANARI_DEVICE:
    return ANARI_DEVICE_info(infoName, infoType);
  case ANARI_ARRAY1D:
    return ANARI_ARRAY1D_info(infoName, infoType);
  case ANARI_ARRAY2D:
    return ANARI_ARRAY2D_info(infoName, infoType);
  case ANARI_ARRAY3D:
    return ANARI_ARRAY3D_info(infoName, infoType);
  case ANARI_FRAME:
    return ANARI_FRAME_info(infoName, infoType);
  case ANARI_GROUP:
    return ANARI_GROUP_info(infoName, infoType);
  case ANARI_WORLD:
    return ANARI_WORLD_info(infoName, infoType);
  case ANARI_SURFACE:
    return ANARI_SURFACE_info(infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_object_info(ANARIDataType type,
    const char *subtype,
    const char *infoNameString,
    ANARIDataType infoType)
{
  int infoName = info_hash(infoNameString);
  return query_object_info_enum(type, subtype, infoName, infoType);
}
} // namespace anari_ospray
